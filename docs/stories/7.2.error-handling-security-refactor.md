# Story 7.2: Error Handling Security Refactor - Secure Error Information Management

## Status
Draft

## Story
**As a** system administrator,
**I want** error messages to be sanitized and not leak sensitive information,
**so that** system errors do not expose private keys, API keys, or other sensitive data

## Acceptance Criteria
1. Custom error type hierarchy implemented (ValidationError, ConfigurationError, NetworkError, SecurityError)
2. Error message sanitization system created to filter sensitive information
3. Unified error handling middleware implemented across all service layers
4. Error context preservation system for debugging without exposing sensitive data
5. Secure error logging system implemented with different levels for users vs developers
6. All existing error handling updated to use new secure error system
7. Comprehensive error handling tests added covering all error scenarios and security cases

## Tasks / Subtasks

### Task 1: Create Custom Error Type Hierarchy (AC: 1)
- [ ] Design and implement base error class with secure properties
- [ ] Create ValidationError class for input validation failures
- [ ] Create ConfigurationError class for config-related issues
- [ ] Create NetworkError class for API/network failures
- [ ] Create SecurityError class for security-related incidents
- [ ] Add unit tests for all custom error types and inheritance

### Task 2: Implement Error Message Sanitization (AC: 2)
- [ ] Create sensitive data detection patterns (private keys, API keys, passwords)
- [ ] Implement sanitization filters for different data types
- [ ] Create secure error message formatter
- [ ] Add whitelist for safe error information
- [ ] Create unit tests for sanitization with various sensitive data patterns

### Task 3: Build Unified Error Handling Middleware (AC: 3)
- [ ] Create error handling middleware for command layer
- [ ] Create error handling middleware for service layer
- [ ] Create error handling middleware for utility layer
- [ ] Implement error context capture (request ID, timestamp, user context)
- [ ] Add error aggregation and reporting capabilities
- [ ] Add integration tests for error handling across all layers

### Task 4: Implement Error Context Preservation (AC: 4)
- [ ] Create error context system for debugging information
- [ ] Implement secure context collection (no sensitive data)
- [ ] Create error correlation and chaining system
- [ ] Add performance metrics collection for errors
- [ ] Create developer-friendly error reports with context
- [ ] Add tests for context preservation and correlation

### Task 5: Build Secure Error Logging System (AC: 5)
- [ ] Implement dual-level error logging (user vs developer)
- [ ] Create error log sanitization and filtering
- [ ] Add structured error logging with JSON format
- [ ] Implement error log rotation and retention
- [ ] Create error monitoring and alerting system
- [ ] Add tests for logging system security and functionality

### Task 6: Update All Existing Error Handling (AC: 6)
- [ ] Refactor all service layer error handling to use new error types
- [ ] Update command layer error handling with middleware
- [ ] Refactor utility layer error handling
- [ ] Update all existing tests to work with new error system
- [ ] Verify backward compatibility for error handling
- [ ] Add regression tests for all error scenarios

### Task 7: Comprehensive Error Testing (AC: 7)
- [ ] Create error handling test suite covering all scenarios
- [ ] Add security tests for error message sanitization
- [ ] Create integration tests for error propagation across layers
- [ ] Add performance tests for error handling overhead
- [ ] Create chaos engineering tests for error scenarios
- [ ] Verify test coverage exceeds 95% for error handling code

## Dev Notes

### Previous Story Insights
[Source: Analysis of existing error handling patterns across the codebase]

**Current Error Handling Issues Identified:**
- 22 files using inconsistent `throw new Error()` patterns
- Mixed error handling approaches across different layers
- Error messages potentially exposing sensitive information
- Lack of error context preservation for debugging
- No structured error logging or monitoring
- Inconsistent error user experience across commands

**Learning from Security Audits:**
- Error messages should never expose internal system details
- Sensitive data must be filtered from all error outputs
- Error context should be preserved for debugging without security risks
- Different error levels needed for users vs developers
- Structured error logging essential for monitoring and alerting

### Error Handling Architecture Pattern
[Source: Analysis of current error patterns and enterprise error handling best practices]

**Current Problematic Patterns:**
```javascript
// Found across multiple files - inconsistent error handling
if (!condition) {
  throw new Error(`Invalid configuration: ${sensitiveConfig}`);
}

try {
  await someOperation();
} catch (error) {
  throw error; // Lost context, potential info leakage
}
```

**New Secure Error Handling Pattern:**
```javascript
// Consistent error handling with context preservation
import { ValidationError, NetworkError } from '../utils/errors.js';
import { ErrorHandler } from '../utils/errorHandler.js';

// Service layer
class SomeService {
  async doSomething(params) {
    try {
      this.validateParams(params);
      return await someOperation();
    } catch (error) {
      throw ErrorHandler.wrap(error, {
        service: 'SomeService',
        operation: 'doSomething',
        params: this.sanitizeParams(params)
      });
    }
  }

  validateParams(params) {
    if (!params.required) {
      throw new ValidationError('Required parameter missing', {
        field: 'required',
        value: '[REDACTED]'
      });
    }
  }
}

// Command layer
try {
  await someService.doSomething(params);
} catch (error) {
  ErrorHandler.handleCommandError(error, 'someCommand');
  process.exit(1);
}
```

### Custom Error Type Design
[Source: Enterprise error handling patterns and Node.js error best practices]

**Base Error Class:**
```javascript
export class BaseError extends Error {
  constructor(message, code = 'UNKNOWN_ERROR', context = {}) {
    super(message);
    this.name = this.constructor.name;
    this.code = code;
    this.context = this.sanitizeContext(context);
    this.timestamp = new Date().toISOString();
    this.id = this.generateErrorId();

    Error.captureStackTrace(this, this.constructor);
  }

  sanitizeContext(context) {
    const sanitized = { ...context };
    const sensitiveKeys = ['privateKey', 'apiKey', 'password', 'secret', 'token'];

    for (const key of Object.keys(sanitized)) {
      if (sensitiveKeys.some(sensitive => key.toLowerCase().includes(sensitive))) {
        sanitized[key] = '[REDACTED]';
      }
    }

    return sanitized;
  }

  generateErrorId() {
    return `err_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  toSecureJSON() {
    return {
      id: this.id,
      name: this.name,
      code: this.code,
      message: this.message,
      timestamp: this.timestamp,
      context: this.context
    };
  }
}
```

**Specialized Error Classes:**
```javascript
export class ValidationError extends BaseError {
  constructor(message, field = null, value = null) {
    super(message, 'VALIDATION_ERROR', { field, value: value ? '[REDACTED]' : null });
    this.field = field;
  }
}

export class ConfigurationError extends BaseError {
  constructor(message, configKey = null) {
    super(message, 'CONFIGURATION_ERROR', { configKey });
    this.configKey = configKey;
  }
}

export class NetworkError extends BaseError {
  constructor(message, originalError = null, url = null) {
    super(message, 'NETWORK_ERROR', {
      originalError: originalError?.message,
      url: url ? new URL(url).origin : null
    });
    this.originalError = originalError;
    this.url = url;
  }
}

export class SecurityError extends BaseError {
  constructor(message, severity = 'medium') {
    super(message, 'SECURITY_ERROR', { severity });
    this.severity = severity;
  }
}
```

### Error Message Sanitization Strategy
[Source: Security best practices for error message handling]

**Sensitive Data Patterns:**
```javascript
const SENSITIVE_PATTERNS = [
  // Private keys (0x + 64 hex chars)
  { pattern: /0x[a-fA-F0-9]{64}/g, replacement: '[PRIVATE_KEY_REDACTED]' },
  // API keys (various formats)
  { pattern: /sk_[a-zA-Z0-9]{20,}/g, replacement: '[API_KEY_REDACTED]' },
  { pattern: /xoxb-[0-9]{10,}-[0-9]{10,}-[a-zA-Z0-9]{24}/g, replacement: '[BOT_TOKEN_REDACTED]' },
  // Passwords in URLs
  { pattern: /\/\/([^:]+):([^@]+)@/g, replacement: '//$1:[PASSWORD_REDACTED]@' },
  // Email addresses
  { pattern: /\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b/g, replacement: '[EMAIL_REDACTED]' },
  // Phone numbers
  { pattern: /\b\d{3}[-.]?\d{3}[-.]?\d{4}\b/g, replacement: '[PHONE_REDACTED]' }
];

export function sanitizeErrorMessage(message) {
  let sanitized = message;

  for (const { pattern, replacement } of SENSITIVE_PATTERNS) {
    sanitized = sanitized.replace(pattern, replacement);
  }

  return sanitized;
}
```

### Error Context Preservation System
[Source: Distributed systems error tracking patterns]

**Context Collection Strategy:**
```javascript
export class ErrorContext {
  constructor() {
    this.requestId = this.generateRequestId();
    this.timestamp = new Date().toISOString();
    this.stack = [];
    this.metadata = {};
  }

  addLayer(layer, data) {
    this.stack.push({
      layer,
      timestamp: new Date().toISOString(),
      data: this.sanitizeData(data)
    });
  }

  addMetadata(key, value) {
    this.metadata[key] = this.sanitizeData(value);
  }

  sanitizeData(data) {
    if (typeof data === 'string') {
      return sanitizeErrorMessage(data);
    }

    if (typeof data === 'object' && data !== null) {
      const sanitized = {};
      for (const [key, value] of Object.entries(data)) {
        sanitized[key] = this.sanitizeValue(value);
      }
      return sanitized;
    }

    return data;
  }

  sanitizeValue(value) {
    if (typeof value === 'string') {
      return sanitizeErrorMessage(value);
    }

    if (typeof value === 'object' && value !== null) {
      return '[OBJECT_REDACTED]';
    }

    return value;
  }

  generateRequestId() {
    return `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
}
```

### Secure Error Logging Implementation
[Source: Security-focused logging practices and GDPR compliance]

**Dual-Level Logging Strategy:**
```javascript
export class SecureLogger {
  constructor() {
    this.userLogger = logger; // Existing logger for user messages
    this.devLogger = this.createDevLogger();
  }

  logError(error, level = 'error') {
    // User-facing log (sanitized)
    this.userLogger[level](`${error.name}: ${error.message} (ID: ${error.id})`);

    // Developer log (detailed, secure)
    this.devLogger.error('Error details', {
      id: error.id,
      name: error.name,
      code: error.code,
      message: error.message,
      stack: error.stack,
      context: error.context,
      timestamp: error.timestamp
    });
  }

  logSecurityEvent(event, severity = 'medium') {
    // Security events always logged to both levels
    this.userLogger.warn(`Security event detected (ID: ${event.id})`);
    this.devLogger.error('Security event', {
      ...event,
      severity,
      timestamp: new Date().toISOString()
    });

    // High severity security events trigger immediate alerts
    if (severity === 'high') {
      this.triggerSecurityAlert(event);
    }
  }

  createDevLogger() {
    return {
      error: (message, meta = {}) => {
        // Write to secure developer log file
        this.writeToSecureLog('ERROR', message, meta);
      },
      warn: (message, meta = {}) => {
        this.writeToSecureLog('WARN', message, meta);
      },
      info: (message, meta = {}) => {
        this.writeToSecureLog('INFO', message, meta);
      }
    };
  }

  writeToSecureLog(level, message, meta) {
    const logEntry = {
      timestamp: new Date().toISOString(),
      level,
      message,
      meta: this.sanitizeLogData(meta)
    };

    // Write to secure log file with restricted permissions
    // Implementation details depend on security requirements
  }
}
```

### Error Handling Middleware Implementation
[Source: Express.js middleware patterns adapted for CLI applications]

**Service Layer Middleware:**
```javascript
export class ServiceErrorMiddleware {
  static wrap(target, context = {}) {
    return new Proxy(target, {
      get(obj, prop) {
        const value = obj[prop];

        if (typeof value === 'function') {
          return async (...args) => {
            try {
              return await value.apply(obj, args);
            } catch (error) {
              throw ErrorHandler.wrap(error, {
                service: context.serviceName,
                method: prop,
                args: ErrorHandler.sanitizeArgs(args)
              });
            }
          };
        }

        return value;
      }
    });
  }
}

// Usage example
class SomeService {
  async doSomething(params) {
    // Implementation
  }
}

// Wrap service with error middleware
const wrappedService = ServiceErrorMiddleware.wrap(new SomeService(), {
  serviceName: 'SomeService'
});
```

**Command Layer Middleware:**
```javascript
export class CommandErrorMiddleware {
  static handler(commandName) {
    return async (error) => {
      if (error instanceof BaseError) {
        ErrorHandler.handleCommandError(error, commandName);
      } else {
        // Wrap unknown errors
        const wrappedError = new SystemError('An unexpected error occurred', 'UNKNOWN_ERROR');
        ErrorHandler.handleCommandError(wrappedError, commandName);
      }

      process.exit(1);
    };
  }
}

// Usage in commands
command.action(async (options) => {
  try {
    // Command implementation
  } catch (error) {
    CommandErrorMiddleware.handler('commandName')(error);
  }
});
```

### Testing Requirements
[Source: Security testing practices and error handling validation]

**Security Test Categories:**
- Error message sanitization validation
- Sensitive data leakage prevention
- Error context security validation
- Logging security and privacy compliance

**Functional Test Categories:**
- Error type hierarchy and inheritance
- Error propagation across layers
- Error context preservation
- User vs developer error message differentiation

**Integration Test Categories:**
- End-to-end error flow testing
- Error handling middleware integration
- Cross-service error propagation
- Error recovery and resilience testing

### File Locations and Structure
[Source: docs/architecture/source-tree.md]

**New Files to Create:**
- `src/utils/errors.js` - Custom error type definitions
- `src/utils/errorHandler.js` - Error handling middleware and utilities
- `src/utils/errorSanitizer.js` - Error message sanitization
- `src/utils/secureLogger.js` - Secure logging implementation
- `src/__tests__/errors.test.js` - Error type tests
- `src/__tests__/errorHandler.test.js` - Error handler tests
- `src/__tests__/errorSanitizer.test.js` - Sanitization tests

**Files to Modify:**
- All service files (`src/services/*.js`)
- All command files (`src/commands/*.js`)
- Utility files with error handling (`src/utils/*.js`)
- Test files to work with new error system

### Security Considerations
[Source: OWASP error handling guidelines and security best practices]

**Critical Security Requirements:**
- Never expose internal system details in user-facing error messages
- Sanitize all error messages for sensitive data patterns
- Implement error rate limiting to prevent information harvesting
- Log security events separately and monitor for attack patterns
- Ensure error handling doesn't create performance vulnerabilities

**Privacy Compliance:**
- Don't log personal identifiable information (PII)
- Implement data retention policies for error logs
- Provide mechanisms for error log data deletion
- Ensure error logging complies with GDPR/CCPA requirements

### Performance Considerations
[Source: High-performance error handling patterns]

**Error Handling Optimization:**
- Minimize overhead of error wrapping and context collection
- Use efficient sanitization algorithms
- Implement async logging to avoid blocking operations
- Cache compiled sanitization patterns
- Monitor error handling performance impact

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-01-21 | 1.0 | Initial story creation | Winston (Architect Agent) |

## Dev Agent Record

### Agent Model Used
Claude Sonnet 4.5 (claude-sonnet-4-5-20250929)

### Debug Log References
- Error Analysis (2025-01-21): Found 22 files with inconsistent error handling patterns
- Security Review (2025-01-21): Identified potential sensitive data leakage in error messages
- Architecture Planning (2025-01-21): Designed comprehensive error handling architecture

### Completion Notes List
- Story designed to address critical security gaps in error handling
- Custom error hierarchy provides structured error management
- Sanitization system prevents sensitive data leakage
- Context preservation enables debugging without security risks
- Dual-level logging serves both users and developers appropriately
- Comprehensive testing strategy ensures security and functionality

### File List
**New Files to Create:**
- `src/utils/errors.js` - Custom error type hierarchy
- `src/utils/errorHandler.js` - Error handling middleware
- `src/utils/errorSanitizer.js` - Error message sanitization
- `src/utils/secureLogger.js` - Secure logging system
- `src/__tests__/errors.test.js` - Error type tests
- `src/__tests__/errorHandler.test.js` - Error handler tests
- `src/__tests__/errorSanitizer.test.js` - Sanitization tests

**Files to Modify:**
- All `src/services/*.js` files (8 services)
- All `src/commands/*.js` files (15 commands)
- Selected `src/utils/*.js` files with error handling
- Related test files to work with new error system

**Story File:**
- `docs/stories/7.2.error-handling-security-refactor.md` - This story file