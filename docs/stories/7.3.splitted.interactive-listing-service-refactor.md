# Story 7.3: Interactive Listing Service Refactor - Break Down Monolithic listCommand

> **‚ö†Ô∏è SPLITTED - Â∑≤ÊãÜÂàÜ‰∏∫Â§ö‰∏™Áã¨Á´ãÊïÖ‰∫ã**
>
> Ê≠§ÂéüÂßãÊïÖ‰∫ãÂ∑≤Ë¢´ÊãÜÂàÜ‰∏∫‰ª•‰∏ã4‰∏™Áã¨Á´ãÁöÑÊïÖ‰∫ãÔºåÊØè‰∏™ÊïÖ‰∫ã‰∏ìÊ≥®‰∫éÂçï‰∏ÄËÅåË¥£Ôºö
>
> - **7.3a**: FlowStateManagerÂ∑•ÂÖ∑Á±ª - ‰∫§‰∫íÂºèÁä∂ÊÄÅÁÆ°ÁêÜÂ∑•ÂÖ∑
> - **7.3b**: SelectionManagerÈÄâÊã©Â∑•ÂÖ∑ - NFTÂíåÈõÜÂêàÈÄâÊã©ÈÄªËæë
> - **7.3c**: PricingCalculator‰ª∑Ê†ºËÆ°ÁÆóÊúçÂä° - ‰ª∑Ê†ºËÆ°ÁÆóÂíåË¥πÁî®ÈÄªËæë
> - **7.3d**: InteractiveListingServiceÈõÜÊàê‰∏éÈáçÊûÑ - ÊúçÂä°ÁºñÊéíÂíåÂëΩ‰ª§ÈáçÊûÑ
>
> **ÊãÜÂàÜÂéüÂõ†**: ÂéüÊïÖ‰∫ãËØïÂõæ‰∏ÄÊ¨°ÊÄßÂàõÂª∫4‰∏™Á±ª + ÈáçÊûÑ + ÊµãËØïÔºåËøùÂèç‰∫ÜÊïèÊç∑ÂºÄÂèë"ÊØèÊ¨°Âè™ÂÅö‰∏Ä‰ª∂‰∫ã"ÁöÑÂéüÂàô„ÄÇÊãÜÂàÜÂêéÊØè‰∏™ÊïÖ‰∫ãÈÉΩÊúâÊòéÁ°ÆËåÉÂõ¥ÔºåÂèØ‰ª•Áã¨Á´ãÂºÄÂèëÂíåÊµãËØï„ÄÇ
>
> **üëâ ËØ∑ÂèÇËÄÉ‰∏äËø∞Êñ∞ÊïÖ‰∫ãËøõË°åÂºÄÂèëÂÆûÊñΩ„ÄÇ**

## Status
**SPLITTED** - Â∑≤ÊãÜÂàÜ‰∏∫ 7.3a, 7.3b, 7.3c, 7.3d

## Story
**As a** developer,
**I want** the listCommand.js to be refactored into smaller, focused services,
**so that** the code is more maintainable, testable, and follows single responsibility principle

## Acceptance Criteria
1. `listCommand.js` refactored from 1,359 lines to under 300 lines with only CLI interface logic
2. `InteractiveListingService` created to handle business logic and user flow management
3. `PricingCalculator` service created for all price calculation and fee breakdown logic
4. `SelectionManager` utility created for NFT and collection selection workflows
5. `FlowStateManager` utility created for interactive state management and navigation
6. All new services have comprehensive unit tests with >90% coverage
7. Existing CLI interface and user experience remain completely unchanged

## Tasks / Subtasks

### Task 1: Create FlowStateManager Utility (AC: 5)
- [ ] Extract flow state management logic from listCommand.js
- [ ] Implement state machine for interactive navigation (BACK, CANCEL, NEXT)
- [ ] Create step history and navigation stack management
- [ ] Add state persistence and recovery mechanisms
- [ ] Create unit tests for all state transitions and edge cases

### Task 2: Create SelectionManager Utility (AC: 4)
- [ ] Extract NFT and collection selection logic from listCommand.js
- [ ] Implement search and filtering capabilities
- [ ] Create pagination and navigation for large collections
- [ ] Add selection validation and user preference handling
- [ ] Create unit tests for all selection scenarios

### Task 3: Create PricingCalculator Service (AC: 3)
- [ ] Extract all price calculation logic from listCommand.js
- [ ] Implement floor price difference calculations
- [ ] Create profit margin calculations (absolute and percentage)
- [ ] Add fee breakdown and marketplace fee calculations
- [ ] Create unit tests for all pricing scenarios and edge cases

### Task 4: Create InteractiveListingService (AC: 2)
- [ ] Extract main business logic from listCommand.js
- [ ] Implement orchestration of all new services
- [ ] Create user interaction flow management
- [ ] Add input validation and error handling
- [ ] Create integration tests for complete listing workflow

### Task 5: Refactor listCommand.js (AC: 1, 7)
- [ ] Remove all business logic from listCommand.js
- [ ] Keep only CLI argument parsing and option handling
- [ ] Integrate all new services
- [ ] Maintain exact same CLI interface and behavior
- [ ] Create regression tests to ensure interface compatibility

### Task 6: Comprehensive Testing Suite (AC: 6)
- [ ] Create unit tests for FlowStateManager (state transitions, navigation)
- [ ] Create unit tests for SelectionManager (selection logic, filtering)
- [ ] Create unit tests for PricingCalculator (pricing calculations, fees)
- [ ] Create integration tests for InteractiveListingService
- [ ] Create end-to-end tests for complete listing workflow
- [ ] Verify test coverage exceeds 90% for all new services

### Task 7: Documentation and Validation (AC: 7)
- [ ] Update API documentation for all new services
- [ ] Create developer documentation for service architecture
- [ ] Validate user experience remains identical
- [ ] Performance testing to ensure no degradation
- [ ] Code review to ensure clean separation of concerns

## Dev Notes

### Previous Story Insights
[Source: Analysis of existing listCommand.js implementation and refactoring requirements]

**Current listCommand.js Issues Identified:**
- 1,359 lines of code in single file violating single responsibility principle
- Mixed concerns: CLI parsing, business logic, UI interaction, data processing
- Complex nested async functions creating spaghetti code structure
- Difficult to test individual components in isolation
- High maintenance cost and risk of breaking changes
- Poor code reusability across different commands

**Learning from Architecture Analysis:**
- Large files should be broken down by business responsibility
- UI logic should be separated from business logic
- Common patterns should be extracted into reusable utilities
- Service layer should handle business logic, command layer should handle CLI

### Current listCommand.js Structure Analysis
[Source: Code analysis of src/commands/listCommand.js (1,359 lines)]

**Major Components Identified:**
1. **CLI Interface** (lines 25-100): Command definition, options, argument parsing
2. **Interactive Flow State Machine** (lines 200-400): Navigation, back stack, flow control
3. **Selection Logic** (lines 400-650): NFT/collection search, filtering, pagination
4. **Pricing Calculations** (lines 650-850): Floor price, profit margins, fee calculations
5. **User Interaction** (lines 850-1200): Prompts, confirmations, display formatting
6. **Business Logic** (lines 1200-1359): Order creation, API calls, validation

**Complex Functions Requiring Extraction:**
- `runInteractiveFlow()` (~200 lines) - Main state machine
- `selectCollection()` (~150 lines) - Collection selection logic
- `selectNFT()` (~120 lines) - NFT selection logic
- `calculateListingPrice()` (~100 lines) - Price calculations
- `confirmListing()` (~80 lines) - Confirmation flow

### FlowStateManager Design Pattern
[Source: State machine patterns and interactive CLI best practices]

**State Management Architecture:**
```javascript
export class FlowStateManager {
  constructor() {
    this.currentState = FLOW_STEPS.SELECT_COLLECTION;
    this.history = [];
    this.context = {};
    this.isComplete = false;
  }

  transition(newState, data = null) {
    // Save current state to history
    this.history.push({
      state: this.currentState,
      context: { ...this.context },
      timestamp: Date.now()
    });

    // Update current state
    this.currentState = newState;

    // Update context with new data
    if (data) {
      this.context = { ...this.context, ...data };
    }

    return this.currentState;
  }

  back() {
    if (this.history.length === 0) {
      return BACK_SIGNAL; // Can't go back further
    }

    const previousState = this.history.pop();
    this.currentState = previousState.state;
    this.context = previousState.context;

    return this.currentState;
  }

  cancel() {
    this.isComplete = true;
    return CANCEL_SIGNAL;
  }

  complete(finalData = null) {
    this.isComplete = true;
    if (finalData) {
      this.context = { ...this.context, ...finalData };
    }
    return this.context;
  }

  getCurrentStep() {
    return this.currentState;
  }

  getContext() {
    return { ...this.context };
  }
}
```

**Flow Steps Definition:**
```javascript
export const FLOW_STEPS = {
  SELECT_COLLECTION: 'select-collection',
  SELECT_NFT: 'select-nft',
  SELECT_PRICING_METHOD: 'select-pricing-method',
  INPUT_PRICING_VALUE: 'input-pricing-value',
  CONFIRM: 'confirm',
  DONE: 'done',
  CANCELLED: 'cancelled'
};

export const TRANSITIONS = {
  [FLOW_STEPS.SELECT_COLLECTION]: [
    FLOW_STEPS.SELECT_NFT,
    FLOW_STEPS.CANCELLED
  ],
  [FLOW_STEPS.SELECT_NFT]: [
    FLOW_STEPS.SELECT_PRICING_METHOD,
    FLOW_STEPS.SELECT_COLLECTION, // Back
    FLOW_STEPS.CANCELLED
  ],
  // ... other transitions
};
```

### SelectionManager Implementation Pattern
[Source: UI selection patterns and large dataset handling]

**Selection Management Architecture:**
```javascript
export class SelectionManager {
  constructor(options = {}) {
    this.pageSize = options.pageSize || 10;
    this.searchEnabled = options.searchEnabled !== false;
    this.filters = options.filters || {};
  }

  async selectFromList(items, options = {}) {
    const {
      title = 'Select an item',
      searchPlaceholder = 'Search...',
      allowSearch = this.searchEnabled,
      allowBack = true,
      allowCancel = true
    } = options;

    // Filter items based on current filters
    let filteredItems = this.applyFilters(items);

    // Handle search
    if (allowSearch) {
      const searchTerm = await this.promptSearch(searchPlaceholder);
      if (searchTerm) {
        filteredItems = this.searchItems(filteredItems, searchTerm);
      }
    }

    // Handle pagination for large lists
    if (filteredItems.length > this.pageSize) {
      return await this.selectWithPagination(filteredItems, title, { allowBack, allowCancel });
    }

    // Direct selection for smaller lists
    return await this.selectDirect(filteredItems, title, { allowBack, allowCancel });
  }

  async selectWithPagination(items, title, options) {
    let currentPage = 0;
    const totalPages = Math.ceil(items.length / this.pageSize);

    while (true) {
      const startIndex = currentPage * this.pageSize;
      const endIndex = startIndex + this.pageSize;
      const pageItems = items.slice(startIndex, endIndex);

      const choices = pageItems.map((item, index) => ({
        name: this.formatItem(item),
        value: startIndex + index
      }));

      if (options.allowBack) {
        choices.push({ name: '‚Üê Back', value: BACK_SIGNAL });
      }

      if (currentPage < totalPages - 1) {
        choices.push({ name: '‚Üí Next Page', value: 'NEXT' });
      }

      if (currentPage > 0) {
        choices.push({ name: '‚Üê Previous Page', value: 'PREV' });
      }

      if (options.allowCancel) {
        choices.push({ name: '‚úó Cancel', value: CANCEL_SIGNAL });
      }

      const choice = await prompt({
        type: 'select',
        name: 'selection',
        message: `${title} (Page ${currentPage + 1}/${totalPages})`,
        choices
      });

      if (choice === BACK_SIGNAL) return BACK_SIGNAL;
      if (choice === CANCEL_SIGNAL) return CANCEL_SIGNAL;
      if (choice === 'NEXT') {
        currentPage++;
        continue;
      }
      if (choice === 'PREV') {
        currentPage--;
        continue;
      }

      return items[choice];
    }
  }

  applyFilters(items) {
    return items.filter(item => {
      for (const [key, value] of Object.entries(this.filters)) {
        if (item[key] !== value) return false;
      }
      return true;
    });
  }

  searchItems(items, searchTerm) {
    const searchLower = searchTerm.toLowerCase();
    return items.filter(item => {
      return Object.values(item).some(value =>
        String(value).toLowerCase().includes(searchLower)
      );
    });
  }
}
```

### PricingCalculator Service Design
[Source: Financial calculation patterns and pricing logic analysis]

**Pricing Calculation Architecture:**
```javascript
export class PricingCalculator {
  constructor(chainConfig) {
    this.chainConfig = chainConfig;
    this.wethAddress = chainConfig.wethAddress;
  }

  async calculateListingPrice(nft, pricingMethod, pricingValue, options = {}) {
    switch (pricingMethod) {
      case 'absolute':
        return this.calculateAbsolutePrice(pricingValue);

      case 'floor-difference':
        return this.calculateFloorDifferencePrice(nft, pricingValue);

      case 'profit-margin':
        return this.calculateProfitMarginPrice(nft, pricingValue, options);

      case 'profit-percent':
        return this.calculateProfitPercentPrice(nft, pricingValue, options);

      default:
        throw new Error(`Unknown pricing method: ${pricingMethod}`);
    }
  }

  calculateAbsolutePrice(priceEth) {
    return {
      price: parseUnits(priceEth.toString(), 18),
      displayPrice: priceEth,
      method: 'absolute',
      calculation: `Fixed price: ${priceEth} ETH`
    };
  }

  async calculateFloorDifferencePrice(nft, floorDiff) {
    const floorPrice = await this.getFloorPrice(nft.collection);
    const multiplier = this.parseFloorDifference(floorDiff);

    const calculatedPrice = floorPrice * multiplier;

    return {
      price: parseUnits(calculatedPrice.toString(), 18),
      displayPrice: calculatedPrice,
      method: 'floor-difference',
      calculation: `Floor: ${formatUnits(floorPrice, 18)} ETH √ó ${multiplier} = ${calculatedPrice} ETH`,
      floorPrice,
      floorDiff
    };
  }

  async calculateProfitMarginPrice(nft, profitMargin, options = {}) {
    const purchasePrice = await this.getPurchasePrice(nft, options.purchaseTxHash);
    if (!purchasePrice) {
      throw new Error('Cannot calculate profit margin: purchase price not found');
    }

    const calculatedPrice = purchasePrice + profitMargin;

    return {
      price: parseUnits(calculatedPrice.toString(), 18),
      displayPrice: calculatedPrice,
      method: 'profit-margin',
      calculation: `Purchase: ${formatUnits(purchasePrice, 18)} ETH + ${profitMargin} ETH = ${calculatedPrice} ETH`,
      purchasePrice,
      profitMargin
    };
  }

  calculateFeeBreakdown(listingPrice, options = {}) {
    const {
      marketplaceFee = 0.025, // 2.5% default
      creatorRoyalty = 0,
      payOptionalRoyalties = false
    } = options;

    const marketplaceFeeAmount = listingPrice * marketplaceFee;
    const creatorRoyaltyAmount = payOptionalRoyalties ? listingPrice * creatorRoyalty : 0;
    const totalFees = marketplaceFeeAmount + creatorRoyaltyAmount;
    const netPrice = listingPrice - totalFees;

    return {
      listingPrice,
      marketplaceFee: {
        percentage: marketplaceFee,
        amount: marketplaceFeeAmount
      },
      creatorRoyalty: {
        percentage: creatorRoyalty,
        amount: creatorRoyaltyAmount,
        optional: !payOptionalRoyalties
      },
      totalFees,
      netPrice,
      effectiveRate: (netPrice / listingPrice)
    };
  }

  parseFloorDifference(floorDiff) {
    if (typeof floorDiff === 'number') {
      return 1 + floorDiff; // e.g., 0.1 -> 1.1 (10% above floor)
    }

    if (typeof floorDiff === 'string') {
      if (floorDiff.startsWith('+')) {
        const value = parseFloat(floorDiff.slice(1));
        return floorDiff.includes('%') ? 1 + (value / 100) : 1 + value;
      } else if (floorDiff.startsWith('-')) {
        const value = parseFloat(floorDiff.slice(1));
        return floorDiff.includes('%') ? 1 - (value / 100) : 1 - value;
      }
    }

    throw new Error(`Invalid floor difference format: ${floorDiff}`);
  }

  async getFloorPrice(collectionSlug) {
    // Implementation would call OpenSea API or cache
    // This is a placeholder for the actual implementation
    throw new Error('getFloorPrice must be implemented with API integration');
  }

  async getPurchasePrice(nft, txHash) {
    // Implementation would find the purchase transaction
    // This is a placeholder for the actual implementation
    throw new Error('getPurchasePrice must be implemented with transaction history');
  }
}
```

### InteractiveListingService Orchestration
[Source: Service orchestration patterns and business logic separation]

**Service Orchestration Architecture:**
```javascript
export class InteractiveListingService {
  constructor(dependencies) {
    this.openseaApi = dependencies.openseaApi;
    this.cacheService = dependencies.cacheService;
    this.wallet = dependencies.wallet;
    this.chainConfig = dependencies.chainConfig;
    this.walletAddress = dependencies.walletAddress;

    // Initialize utility services
    this.flowStateManager = new FlowStateManager();
    this.selectionManager = new SelectionManager({
      pageSize: 10,
      searchEnabled: true
    });
    this.pricingCalculator = new PricingCalculator(this.chainConfig);
  }

  async runInteractiveListing(options = {}) {
    try {
      // Initialize flow with cache data
      const cacheData = await this.cacheService.loadCache(this.walletAddress, this.chainConfig.chain);

      if (!cacheData || !cacheData.nfts?.length) {
        throw new Error('No cached NFTs found. Run "cache refresh" first.');
      }

      this.flowStateManager.transition(FLOW_STEPS.SELECT_COLLECTION, {
        cacheData,
        options
      });

      // Main interactive loop
      while (!this.flowStateManager.isComplete) {
        const currentStep = this.flowStateManager.getCurrentStep();

        switch (currentStep) {
          case FLOW_STEPS.SELECT_COLLECTION:
            await this.handleCollectionSelection();
            break;

          case FLOW_STEPS.SELECT_NFT:
            await this.handleNFTSelection();
            break;

          case FLOW_STEPS.SELECT_PRICING_METHOD:
            await this.handlePricingMethodSelection();
            break;

          case FLOW_STEPS.INPUT_PRICING_VALUE:
            await this.handlePricingValueInput();
            break;

          case FLOW_STEPS.CONFIRM:
            await this.handleConfirmation();
            break;

          default:
            throw new Error(`Unknown flow step: ${currentStep}`);
        }
      }

      return this.flowStateManager.getContext();
    } catch (error) {
      logger.error('Interactive listing failed:', error);
      throw error;
    }
  }

  async handleCollectionSelection() {
    const { cacheData } = this.flowStateManager.getContext();
    const collections = this.extractCollectionsFromCache(cacheData);

    const selectedCollection = await this.selectionManager.selectFromList(collections, {
      title: 'Select a collection',
      allowBack: false,
      allowCancel: true
    });

    if (selectedCollection === CANCEL_SIGNAL) {
      return this.flowStateManager.cancel();
    }

    const nftsInCollection = cacheData.nfts.filter(
      nft => nft.collection.slug === selectedCollection.slug
    );

    this.flowStateManager.transition(FLOW_STEPS.SELECT_NFT, {
      selectedCollection,
      availableNFTs: nftsInCollection
    });
  }

  async handleNFTSelection() {
    const { availableNFTs } = this.flowStateManager.getContext();

    const selectedNFT = await this.selectionManager.selectFromList(availableNFTs, {
      title: 'Select an NFT to list',
      allowBack: true,
      allowCancel: true
    });

    if (selectedNFT === BACK_SIGNAL) {
      this.flowStateManager.back();
      return;
    }

    if (selectedNFT === CANCEL_SIGNAL) {
      return this.flowStateManager.cancel();
    }

    this.flowStateManager.transition(FLOW_STEPS.SELECT_PRICING_METHOD, {
      selectedNFT
    });
  }

  async handlePricingMethodSelection() {
    const pricingMethods = [
      { name: 'Fixed Price (ETH)', value: 'absolute' },
      { name: 'Floor Price Difference', value: 'floor-difference' },
      { name: 'Profit Margin (ETH)', value: 'profit-margin' },
      { name: 'Profit Percentage', value: 'profit-percent' }
    ];

    const selectedMethod = await prompt({
      type: 'select',
      name: 'method',
      message: 'Select pricing method:',
      choices: [
        ...pricingMethods,
        { name: '‚Üê Back', value: BACK_SIGNAL },
        { name: '‚úó Cancel', value: CANCEL_SIGNAL }
      ]
    });

    if (selectedMethod === BACK_SIGNAL) {
      this.flowStateManager.back();
      return;
    }

    if (selectedMethod === CANCEL_SIGNAL) {
      return this.flowStateManager.cancel();
    }

    this.flowStateManager.transition(FLOW_STEPS.INPUT_PRICING_VALUE, {
      pricingMethod: selectedMethod
    });
  }

  async handlePricingValueInput() {
    const { pricingMethod, selectedNFT } = this.flowStateManager.getContext();

    let pricingValue;
    switch (pricingMethod) {
      case 'absolute':
        pricingValue = await this.promptAbsolutePrice();
        break;
      case 'floor-difference':
        pricingValue = await this.promptFloorDifference();
        break;
      case 'profit-margin':
        pricingValue = await this.promptProfitMargin();
        break;
      case 'profit-percent':
        pricingValue = await this.promptProfitPercentage();
        break;
    }

    if (pricingValue === BACK_SIGNAL) {
      this.flowStateManager.back();
      return;
    }

    // Calculate final price
    const priceCalculation = await this.pricingCalculator.calculateListingPrice(
      selectedNFT,
      pricingMethod,
      pricingValue,
      this.flowStateManager.getContext()
    );

    this.flowStateManager.transition(FLOW_STEPS.CONFIRM, {
      pricingValue,
      priceCalculation
    });
  }

  async handleConfirmation() {
    const { selectedNFT, priceCalculation, pricingMethod } = this.flowStateManager.getContext();

    // Display detailed confirmation
    this.displayListingConfirmation(selectedNFT, priceCalculation);

    const confirmed = await prompt({
      type: 'confirm',
      name: 'confirmed',
      message: 'Confirm this listing?'
    });

    if (!confirmed) {
      this.flowStateManager.back();
      return;
    }

    // Execute the listing
    const listingResult = await this.executeListing(selectedNFT, priceCalculation);

    this.flowStateManager.complete({
      listingResult,
      confirmed: true
    });
  }

  // Additional helper methods for prompts, display, and listing execution
  extractCollectionsFromCache(cacheData) {
    const collectionMap = new Map();

    for (const nft of cacheData.nfts) {
      const collection = nft.collection;
      if (!collectionMap.has(collection.slug)) {
        collectionMap.set(collection.slug, {
          ...collection,
          nftCount: 0
        });
      }
      collectionMap.get(collection.slug).nftCount++;
    }

    return Array.from(collectionMap.values());
  }

  displayListingConfirmation(nft, priceCalculation) {
    const feeBreakdown = this.pricingCalculator.calculateFeeBreakdown(
      priceCalculation.price,
      { marketplaceFee: 0.025 } // Default 2.5%
    );

    logger.info('\n=== Listing Confirmation ===');
    logger.info(`NFT: ${nft.name || nft.tokenId} (${nft.collection.name})`);
    logger.info(`Method: ${priceCalculation.method}`);
    logger.info(`Calculation: ${priceCalculation.calculation}`);
    logger.info(`List Price: ${priceCalculation.displayPrice} ETH`);
    logger.info(`Marketplace Fee (2.5%): ${formatUnits(feeBreakdown.marketplaceFee.amount, 18)} ETH`);
    logger.info(`You'll Receive: ${formatUnits(feeBreakdown.netPrice, 18)} ETH`);
    logger.info('========================\n');
  }

  async executeListing(nft, priceCalculation) {
    // This would integrate with OpenSea API to create the actual listing
    // Implementation depends on the specific OpenSea SDK methods
    throw new Error('Listing execution must be implemented with OpenSea API integration');
  }
}
```

### Refactored listCommand.js Structure
[Source: Command layer patterns and separation of concerns]

**Simplified Command Implementation:**
```javascript
import { Command } from 'commander';
import { logger, LogLevel } from '../utils/logger.js';
import { OPENSEA_API_KEY, OPENSEA_API_BASE_URL } from '../config.js';
import { addChainOption, getEffectiveChain, addPrivateKeyOption, getWallet } from '../utils/commandUtils.js';
import { OpenSeaApi } from '../services/openseaApi.js';
import { CacheService } from '../services/cacheService.js';
import { InteractiveListingService } from '../services/InteractiveListingService.js';

export const listCommand = new Command('list')
  .description('List an NFT for sale on multiple marketplaces')
  .option('-a, --address <address>', 'NFT contract address')
  .option('-t, --token-id <tokenId>', 'Token ID')
  .option('-i, --interactive', 'Select NFT interactively from cache')
  .option('-p, --price <price>', 'Absolute listing price in ETH')
  .option('-f, --floor-diff <diff>', 'Price difference from floor price')
  .option('--profit-margin <margin>', 'Profit margin over last purchase price')
  .option('--profit-percent <percent>', 'Profit percentage over last purchase price')
  .option('-e, --expiration <time>', 'Expiration time', '1h')
  .option('-m, --marketplaces <markets>', 'Comma-separated list of marketplaces', 'opensea')
  .option('--pay-optional-royalties', 'Pay optional creator royalties')
  .option('--skip-confirm', 'Skip listing confirmation')
  .option('--debug', 'Enable debug logging');

// Add chain and private key options
addChainOption(listCommand);
addPrivateKeyOption(listCommand);

listCommand.action(async (options) => {
  try {
    // Validate options
    validateOptions(options);

    // Setup common dependencies
    const dependencies = await setupDependencies(options);

    if (options.interactive) {
      // Interactive mode - delegate to service
      const interactiveService = new InteractiveListingService(dependencies);
      const result = await interactiveService.runInteractiveListing(options);

      if (result.confirmed) {
        logger.info('‚úÖ Listing created successfully!');
        logger.info(`Transaction: ${result.listingResult.transactionHash}`);
      } else {
        logger.info('‚ùå Listing cancelled');
      }
    } else {
      // Direct listing mode
      const result = await createDirectListing(dependencies, options);
      logger.info('‚úÖ Listing created successfully!');
      logger.info(`Transaction: ${result.transactionHash}`);
    }

  } catch (error) {
    logger.error('List command failed:', error.message);
    process.exit(1);
  }
});

function validateOptions(options) {
  if (options.interactive && (options.address || options.tokenId)) {
    throw new Error('Cannot use --interactive with --address or --token-id');
  }

  if (!options.interactive && (!options.address || !options.tokenId)) {
    throw new Error('Must provide both --address and --token-id, or use --interactive');
  }

  // Additional validation for pricing options
  const pricingOptions = [options.price, options.floorDiff, options.profitMargin, options.profitPercent];
  const activePricingOptions = pricingOptions.filter(option => option !== undefined);

  if (activePricingOptions.length > 1) {
    throw new Error('Cannot specify multiple pricing options simultaneously');
  }
}

async function setupDependencies(options) {
  const chainConfig = await getEffectiveChain(options);
  const wallet = await getWallet(options);
  const walletAddress = await wallet.getAddress();

  if (options.debug) {
    logger.setLevel(LogLevel.DEBUG);
  }

  const openseaApi = new OpenSeaApi(OPENSEA_API_KEY, OPENSEA_API_BASE_URL, chainConfig);
  const cacheService = new CacheService();

  return {
    openseaApi,
    cacheService,
    wallet,
    chainConfig,
    walletAddress
  };
}

async function createDirectListing(dependencies, options) {
  // Implementation for direct (non-interactive) listing
  // This would use the same underlying services but with pre-defined parameters
  throw new Error('Direct listing implementation needed');
}

export default listCommand;
```

### Testing Strategy
[Source: Testing best practices and service isolation patterns]

**Unit Testing Categories:**
- **FlowStateManager**: State transitions, navigation stack, context management
- **SelectionManager**: Search, filtering, pagination, selection logic
- **PricingCalculator**: All pricing calculations, fee breakdowns, edge cases
- **InteractiveListingService**: Service orchestration, workflow integration

**Integration Testing Categories:**
- Complete interactive listing workflow
- Service integration and dependency injection
- Error handling across service boundaries
- User interaction simulation

**Regression Testing Categories:**
- CLI interface compatibility
- User experience consistency
- Performance comparison with original implementation
- Memory usage and resource management

### File Locations and Structure
[Source: docs/architecture/source-tree.md]

**New Files to Create:**
- `src/services/InteractiveListingService.js` - Main orchestration service
- `src/utils/FlowStateManager.js` - State management utility
- `src/utils/SelectionManager.js` - Selection logic utility
- `src/utils/PricingCalculator.js` - Pricing calculation service
- `src/__tests__/InteractiveListingService.test.js` - Service tests
- `src/__tests__/FlowStateManager.test.js` - State manager tests
- `src/__tests__/SelectionManager.test.js` - Selection tests
- `src/__tests__/PricingCalculator.test.js` - Pricing tests

**Files to Modify:**
- `src/commands/listCommand.js` - Simplify to <300 lines
- Related test files to work with new structure

### Performance Considerations
[Source: Performance optimization patterns and large dataset handling]

**Optimization Strategies:**
- Lazy loading of large datasets
- Efficient search and filtering algorithms
- Pagination to minimize memory usage
- Caching of expensive calculations
- Async operations to prevent UI blocking

**Memory Management:**
- Clear unused data from context
- Use streams for large dataset processing
- Implement garbage collection for completed flows
- Monitor memory usage during interactive sessions

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-01-21 | 1.0 | Initial story creation | Winston (Architect Agent) |

## Dev Agent Record

### Agent Model Used
Claude Sonnet 4.5 (claude-sonnet-4-5-20250929)

### Debug Log References
- Code Analysis (2025-01-21): Identified 1,359-line monolithic listCommand.js requiring refactoring
- Architecture Planning (2025-01-21): Designed service separation strategy
- Performance Analysis (2025-01-21): Planned optimization strategies for interactive flows

### Completion Notes List
- Comprehensive refactoring plan for largest command file
- Service architecture designed for maintainability and testability
- State management system for complex interactive flows
- Selection utility for handling large datasets efficiently
- Pricing calculator with support for multiple pricing strategies
- Testing strategy ensuring 90%+ coverage for all new services

### File List
**New Files to Create:**
- `src/services/InteractiveListingService.js` - Main business logic service
- `src/utils/FlowStateManager.js` - Interactive state management
- `src/utils/SelectionManager.js` - NFT/collection selection logic
- `src/utils/PricingCalculator.js` - Price calculation service
- `src/__tests__/InteractiveListingService.test.js` - Service integration tests
- `src/__tests__/FlowStateManager.test.js` - State manager unit tests
- `src/__tests__/SelectionManager.test.js` - Selection logic tests
- `src/__tests__/PricingCalculator.test.js` - Pricing calculation tests

**Files to Modify:**
- `src/commands/listCommand.js` - Refactor from 1,359 to <300 lines
- Related test files for compatibility with new architecture

**Story File:**
- `docs/stories/7.3.interactive-listing-service-refactor.md` - This story file