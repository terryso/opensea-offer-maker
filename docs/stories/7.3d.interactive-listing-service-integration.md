# Story 7.3d: InteractiveListingService Integration - Orchestration and Command Refactor

## Status
Draft

## Story
**As a** developer,
**I want** an InteractiveListingService that orchestrates all the new utility services and refactors listCommand.js,
**so that** the monolithic listCommand is simplified to under 300 lines while maintaining the exact same CLI interface and user experience

## Acceptance Criteria
1. Create `InteractiveListingService` class in `src/services/InteractiveListingService.js` that orchestrates FlowStateManager, SelectionManager, and PricingCalculator
2. Refactor `listCommand.js` from 1,359 lines to under 300 lines, keeping only CLI interface logic
3. Implement main business logic orchestration with proper error handling and user interaction flows
4. Maintain exact same CLI interface and user experience with no breaking changes
5. Create comprehensive integration tests and unit tests with >90% coverage for the service and command
6. Ensure regression tests validate interface compatibility and identical user behavior

## Tasks / Subtasks

- [ ] Task 1: Create InteractiveListingService class structure (AC: 1)
  - [ ] Define service class with dependency injection for all utilities
  - [ ] Initialize FlowStateManager, SelectionManager, and PricingCalculator
  - [ ] Set up OpenSea API and CacheService integration
  - [ ] Add constructor with proper dependency validation

- [ ] Task 2: Implement main business logic orchestration (AC: 3)
  - [ ] Create `runInteractiveListing()` method as main entry point
  - [ ] Implement `handleCollectionSelection()` using SelectionManager
  - [ ] Add `handleNFTSelection()` with FlowStateManager coordination
  - [ ] Create `handlePricingMethodSelection()` and pricing workflow
  - [ ] Implement `handleConfirmation()` with fee breakdown display
  - [ ] Add `executeListing()` method for final order creation

- [ ] Task 3: Refactor listCommand.js to use new service (AC: 2, 4)
  - [ ] Remove all business logic from listCommand.js (target: <300 lines)
  - [ ] Keep only CLI argument parsing and option handling
  - [ ] Integrate InteractiveListingService for interactive mode
  - [ ] Implement direct listing mode using service components
  - [ ] Maintain exact same CLI interface and behavior

- [ ] Task 4: Create comprehensive test suite (AC: 5)
  - [ ] Create unit tests for InteractiveListingService methods
  - [ ] Create integration tests for complete listing workflow
  - [ ] Create end-to-end tests for listCommand.js behavior
  - [ ] Mock all external dependencies (OpenSea API, prompts)
  - [ ] Verify >90% code coverage for all new code

- [ ] Task 5: Create regression tests and validation (AC: 6)
  - [ ] Create tests that validate CLI interface compatibility
  - [ ] Add tests for all command options and parameter combinations
  - [ ] Verify user experience remains identical through integration testing
  - [ ] Create performance tests to ensure no degradation
  - [ ] Add tests for error handling and edge cases

- [ ] Task 6: Documentation and cleanup (AC: 6)
  - [ ] Update API documentation for new service
  - [ ] Create developer documentation for new architecture
  - [ ] Add migration notes and breaking change documentation (none expected)
  - [ ] Validate code quality and standards compliance

## Dev Notes

### Previous Story Insights
[Source: Analysis of Stories 7.1, 7.2, 7.3a, 7.3b, and 7.3c completion]

**Learning from KeyManager Security Refactor (Story 7.1):**
- Proper error handling with custom error types is essential
- Environment variable configuration patterns should be followed
- Service classes work well with existing architecture

**Learning from Error Handling Refactor (Story 7.2):**
- Consistent error messages across the codebase improve debugging
- Logger should be used instead of console.log for all error reporting
- Input validation should be comprehensive and defensive

**Learning from Utility Classes (Stories 7.3a, 7.3b, 7.3c):**
- Modular utility design enables better testing and maintenance
- Clear separation of concerns improves code organization
- Consistent patterns across utilities improve developer experience
- Proper dependency injection enables flexible testing

### Technical Architecture Context

**Service Orchestration Pattern:**
[Source: docs/prd/epic-7-system-refactoring.md#story-73-交互式挂单服务重构]

Based on the epic requirements, the InteractiveListingService needs to:

- **Extract main business logic** from listCommand.js (lines 1200-1359)
- **Orchestrate all new services** (FlowStateManager, SelectionManager, PricingCalculator)
- **Handle user interaction flows** with proper state management
- **Maintain existing CLI interface** and user experience exactly

**Service Integration Architecture:**
```javascript
// Service composition pattern
export class InteractiveListingService {
  constructor(dependencies) {
    this.openseaApi = dependencies.openseaApi;
    this.cacheService = dependencies.cacheService;
    this.wallet = dependencies.wallet;
    this.chainConfig = dependencies.chainConfig;
    this.walletAddress = dependencies.walletAddress;

    // Initialize utility services
    this.flowStateManager = new FlowStateManager();
    this.selectionManager = new SelectionManager({
      pageSize: 10,
      searchEnabled: true
    });
    this.pricingCalculator = new PricingCalculator(this.chainConfig);
  }
}
```

### Current listCommand.js Analysis
[Source: docs/architecture/source-tree.md and code analysis]

**Current State:** 1,359 lines in single file
**Target State:** <300 lines with only CLI interface logic

**Major Components to Extract:**
1. **Interactive Flow State Machine** (lines 200-400) → FlowStateManager
2. **Selection Logic** (lines 400-650) → SelectionManager
3. **Pricing Calculations** (lines 650-850) → PricingCalculator
4. **User Interaction** (lines 850-1200) → InteractiveListingService
5. **Business Logic** (lines 1200-1359) → InteractiveListingService

**Components to Keep in listCommand.js:**
- CLI argument parsing and option handling (~25-100 lines)
- Service dependency setup and initialization
- Error handling and user feedback
- Integration with InteractiveListingService

### File Location and Structure
[Source: docs/architecture/source-tree.md]

**New Service Location:** `src/services/InteractiveListingService.js`

The services directory contains business logic services:
- `buyService.js` - NFT purchase service
- `cacheService.js` - File caching system
- `notificationService.js` - Event notification system
- `offerService.js` - Offer creation service
- `offerStrategy.js` - Automatic bidding strategy
- `openseaApi.js` - OpenSea API wrapper
- `pollingMonitorService.js` - Polling-based monitoring
- `streamService.js` - WebSocket-based streaming

InteractiveListingService should follow service patterns:
- ES Module exports (export class, export default)
- Dependency injection through constructor
- Integration with existing services
- Comprehensive error handling
- Business logic orchestration

**Modified File:** `src/commands/listCommand.js`
- Reduce from 1,359 to <300 lines
- Remove business logic
- Keep CLI interface
- Add service integration

### Service Integration Dependencies

**Required Dependencies:**
- `FlowStateManager` from `./utils/FlowStateManager.js` (Story 7.3a)
- `SelectionManager` from `./utils/SelectionManager.js` (Story 7.3b)
- `PricingCalculator` from `./utils/PricingCalculator.js` (Story 7.3c)
- `OpenSeaApi` from `./services/openseaApi.js` (existing)
- `CacheService` from `./services/cacheService.js` (existing)

**Integration Pattern:**
```javascript
// Dependency injection pattern
const dependencies = await setupDependencies(options);
const interactiveService = new InteractiveListingService(dependencies);
const result = await interactiveService.runInteractiveListing(options);
```

### User Interaction Flow Management

**Complete Workflow:**
1. **Cache Validation** → Load cached NFT data
2. **Collection Selection** → Use SelectionManager for collection choice
3. **NFT Selection** → Use SelectionManager for NFT choice
4. **Pricing Method** → Select pricing strategy
5. **Pricing Input** → Input pricing values based on method
6. **Confirmation** → Display listing details with fees
7. **Execution** → Create listing via OpenSea API

**State Management Integration:**
- Use FlowStateManager for navigation and history
- Support BACK, CANCEL, and flow completion
- Maintain context across all steps
- Handle error recovery and flow restart

### Coding Standards
[Source: docs/architecture/coding-standards.md]

**Requirements:**
- Use ES2022 with ES Modules (package.json has `"type": "module"`)
- Follow camelCase file naming (`InteractiveListingService.js`)
- Use PascalCase for class names (`class InteractiveListingService`)
- Use logger from `src/utils/logger.js` - never console.log
- Proper error handling with try/catch blocks
- Add comprehensive JSDoc comments for public methods

**Service Pattern Structure:**
```javascript
// src/services/InteractiveListingService.js
import logger from '../utils/logger.js';
import { FlowStateManager } from '../utils/FlowStateManager.js';
import { SelectionManager } from '../utils/SelectionManager.js';
import { PricingCalculator } from '../utils/PricingCalculator.js';

export class InteractiveListingService {
  constructor(dependencies) {
    this.openseaApi = dependencies.openseaApi;
    this.cacheService = dependencies.cacheService;
    // ... other dependencies

    this.flowStateManager = new FlowStateManager();
    this.selectionManager = new SelectionManager();
    this.pricingCalculator = new PricingCalculator(dependencies.chainConfig);
  }

  // public methods
}

export default InteractiveListingService;
```

### Testing Requirements
[Source: docs/architecture/testing.md]

**Test Files:**
- `src/__tests__/InteractiveListingService.test.js` - Service unit tests
- `src/__tests__/listCommand.test.js` - Updated command tests
- `src/__tests__/interactive-listing.integration.test.js` - Integration tests

**Testing Standards:**
- Use Jest framework with experimental VM modules
- Achieve >90% code coverage for new code
- Mock all external dependencies (OpenSea API, prompts)
- Test complete workflow integration
- Test error handling and edge cases

**Mock Strategy for Testing:**
```javascript
// Mock all utility services
jest.mock('../utils/FlowStateManager.js');
jest.mock('../utils/SelectionManager.js');
jest.mock('../utils/PricingCalculator.js');
jest.mock('../services/openseaApi.js');
jest.mock('../services/cacheService.js');

// Mock prompts for integration testing
jest.mock('enquirer', () => ({
  prompt: jest.fn()
}));
```

**Integration Test Structure:**
```javascript
describe('InteractiveListingService Integration', () => {
  let service;
  let mockDependencies;

  beforeEach(() => {
    mockDependencies = {
      openseaApi: createMockOpenSeaApi(),
      cacheService: createMockCacheService(),
      wallet: createMockWallet(),
      chainConfig: createMockChainConfig(),
      walletAddress: '0x1234567890123456789012345678901234567890'
    };

    service = new InteractiveListingService(mockDependencies);
  });

  describe('runInteractiveListing', () => {
    it('should complete full listing workflow', async () => {
      // Test complete flow from start to finish
    });
  });
});
```

### Command Refactor Specifications

**Current listCommand.js Structure (1,359 lines):**
```javascript
// Current: Massive file with mixed concerns
export const listCommand = new Command('list')
  .description('List an NFT for sale on multiple marketplaces')
  .option('-a, --address <address>', 'NFT contract address')
  // ... many options
  .action(async (options) => {
    // 1,359 lines of business logic, UI, data processing, etc.
  });
```

**Target listCommand.js Structure (<300 lines):**
```javascript
// Target: Clean CLI interface only
import { Command } from 'commander';
import { logger } from '../utils/logger.js';
import { InteractiveListingService } from '../services/InteractiveListingService.js';
import { setupDependencies } from '../utils/commandUtils.js';

export const listCommand = new Command('list')
  .description('List an NFT for sale on multiple marketplaces')
  .option('-a, --address <address>', 'NFT contract address')
  // ... existing options (unchanged)
  .action(async (options) => {
    try {
      // 1. Validate options
      validateOptions(options);

      // 2. Setup dependencies
      const dependencies = await setupDependencies(options);

      // 3. Route to appropriate handling
      if (options.interactive) {
        const service = new InteractiveListingService(dependencies);
        const result = await service.runInteractiveListing(options);
        handleInteractiveResult(result);
      } else {
        const result = await createDirectListing(dependencies, options);
        handleDirectResult(result);
      }

    } catch (error) {
      logger.error('List command failed:', error.message);
      process.exit(1);
    }
  });

// Helper functions (~50 lines total)
function validateOptions(options) { /* validation logic */ }
function handleInteractiveResult(result) { /* result handling */ }
function handleDirectResult(result) { /* result handling */ }
```

### Performance and Compatibility Requirements

**Performance Targets:**
- No degradation in listing creation speed
- Improved memory usage through modular design
- Better error recovery and flow restart capabilities
- Faster development and maintenance through separation of concerns

**Compatibility Requirements:**
- **100% CLI interface compatibility** - All existing options and behaviors must work identically
- **No breaking changes** - Existing scripts and integrations must continue to work
- **Identical user experience** - Same prompts, same flow, same error messages
- **Same configuration** - Environment variables and config files unchanged

### Migration and Deployment Strategy

**Migration Approach:**
- New services can be developed alongside existing listCommand.js
- Gradual migration of functionality to new services
- Final switch-over maintains identical interface
- Rollback capability if issues discovered

**Testing Strategy:**
- Comprehensive regression testing before deployment
- Side-by-side comparison of old vs new behavior
- Performance benchmarking to ensure no degradation
- User acceptance testing with interactive workflows

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-01-21 | 1.0 | Initial story creation for service integration and command refactor | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
[To be populated by development agent]

### Debug Log References
[To be populated by development agent]

### Completion Notes List
[To be populated by development agent]

### File List
**Files to Create:**
- `src/services/InteractiveListingService.js` - Main orchestration service
- `src/__tests__/InteractiveListingService.test.js` - Service unit tests
- `src/__tests__/interactive-listing.integration.test.js` - Integration tests

**Files to Modify:**
- `src/commands/listCommand.js` - Refactor from 1,359 to <300 lines
- `src/__tests__/listCommand.test.js` - Update for new structure

**Files to Reference:**
- All utility services from Stories 7.3a, 7.3b, 7.3c
- `src/services/openseaApi.js` - For API integration patterns
- `src/services/cacheService.js` - For cache integration
- `docs/architecture/` for design patterns and standards

## QA Results
[To be populated by QA agent after implementation]