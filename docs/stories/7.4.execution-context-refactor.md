# Story 7.4: Execution Context Refactor - Unified Common Initialization Logic

## Status
Draft

## Story
**As a** developer,
**I want** a unified initialization and context management system,
**so that** I can reduce code duplication across commands and ensure consistent setup behavior

## Acceptance Criteria
1. `ExecutionContext` utility class created to encapsulate common setup logic (chain, wallet, API clients)
2. All 9+ command files refactored to use ExecutionContext instead of duplicate initialization code
3. 60% reduction in repetitive initialization code across command files
4. Context validation and error handling implemented with comprehensive error messages
5. Context caching and reuse mechanisms implemented for performance optimization
6. Comprehensive unit tests created for ExecutionContext and all integration scenarios
7. All existing command behavior preserved with no breaking changes to CLI interface

## Tasks / Subtasks

### Task 1: Create ExecutionContext Core Class (AC: 1)
- [ ] Design ExecutionContext class with dependency injection support
- [ ] Implement chain configuration loading and validation
- [ ] Implement wallet initialization and address resolution
- [ ] Add API client initialization (OpenSea, caching services)
- [ ] Create context validation and health check methods
- [ ] Add unit tests for all ExecutionContext functionality

### Task 2: Implement Context Validation System (AC: 4)
- [ ] Create comprehensive validation rules for all context components
- [ ] Implement early validation with helpful error messages
- [ ] Add dependency validation between context components
- [ ] Create context health check and diagnostic tools
- [ ] Add validation tests for all error scenarios

### Task 3: Build Context Caching System (AC: 5)
- [ ] Implement context caching with TTL (time-to-live) support
- [ ] Add context invalidation and refresh mechanisms
- [ ] Create memory-efficient context storage
- [ ] Add context sharing between multiple command invocations
- [ ] Add performance tests for caching effectiveness

### Task 4: Refactor Command Files to Use ExecutionContext (AC: 2, 3, 7)
- [ ] Refactor offerCommand.js to use ExecutionContext
- [ ] Refactor listCommand.js to use ExecutionContext
- [ ] Refactor monitorCommand.js to use ExecutionContext
- [ ] Refactor buyCommand.js to use ExecutionContext
- [ ] Refactor autoOfferCommand.js to use ExecutionContext
- [ ] Refactor remaining command files (balance, cache, checkOffers, key, send, swap)
- [ ] Create integration tests to verify behavior preservation

### Task 5: Create Context Builder Pattern (AC: 1)
- [ ] Implement fluent builder pattern for ExecutionContext
- [ ] Add conditional configuration options
- [ ] Create preset configurations for common use cases
- [ ] Add builder validation and error handling
- [ ] Create tests for builder pattern and preset configurations

### Task 6: Performance Optimization and Monitoring (AC: 5)
- [ ] Implement lazy loading for expensive context components
- [ ] Add performance monitoring and metrics collection
- [ ] Create context initialization benchmarks
- [ ] Optimize memory usage and garbage collection
- [ ] Add performance regression tests

### Task 7: Comprehensive Testing Suite (AC: 6)
- [ ] Create unit tests for ExecutionContext class methods
- [ ] Create integration tests for command refactoring
- [ ] Add performance tests for context creation and caching
- [ ] Create error handling tests for validation failures
- [ ] Add end-to-end tests for complete command workflows
- [ ] Verify test coverage exceeds 95% for context-related code

## Dev Notes

### Previous Story Insights
[Source: Analysis of repetitive initialization patterns across command files]

**Current Duplication Issues Identified:**
- 9+ command files contain identical initialization code blocks
- Repetitive chain configuration loading: `getEffectiveChain(options)`
- Repeated wallet setup: `getWallet(options)` + `wallet.getAddress()`
- Duplicated API client initialization patterns
- Inconsistent error handling for initialization failures
- No shared validation or caching mechanisms

**Learning from Code Analysis:**
- Common pattern found in 22 files:
  ```javascript
  const chainConfig = await getEffectiveChain(options);
  const wallet = await getWallet(options);
  const walletAddress = await wallet.getAddress();
  ```
- Each command re-implements similar error handling for these operations
- No shared context validation or health checking
- Performance impact from repeated expensive operations

### Current Command Initialization Patterns
[Source: Analysis of command files showing repetitive patterns]

**Typical Command Initialization Block:**
```javascript
// Found in listCommand.js, monitorCommand.js, buyCommand.js, etc.
const chainConfig = await getEffectiveChain(options);
const wallet = await getWallet(options);
const walletAddress = await wallet.getAddress();

if (options.debug) {
  logger.setLevel(LogLevel.DEBUG);
}

// Additional service initializations...
const openseaApi = new OpenSeaApi(OPENSEA_API_KEY, OPENSEA_API_BASE_URL, chainConfig);
const cacheService = new CacheService();
```

**Variations Found:**
- Some commands include additional service initializations
- Error handling differs between commands
- Debug logging setup is inconsistent
- No shared validation or configuration management

### ExecutionContext Design Pattern
[Source: Context pattern and dependency injection best practices]

**Core ExecutionContext Architecture:**
```javascript
export class ExecutionContext {
  constructor(options = {}) {
    this.options = options;
    this.isInitialized = false;
    this.components = new Map();
    this.validationErrors = [];
    this.performanceMetrics = new Map();
  }

  async init() {
    if (this.isInitialized) {
      return this;
    }

    const startTime = Date.now();

    try {
      // Initialize components in dependency order
      await this.initializeChainConfig();
      await this.initializeWallet();
      await this.initializeAddress();
      await this.initializeApiClients();
      await this.initializeServices();
      await this.validateContext();

      this.isInitialized = true;
      this.recordPerformance('total_init', Date.now() - startTime);

      return this;
    } catch (error) {
      throw new ContextInitializationError('Failed to initialize execution context', error);
    }
  }

  get chainConfig() {
    this.ensureInitialized();
    return this.components.get('chainConfig');
  }

  get wallet() {
    this.ensureInitialized();
    return this.components.get('wallet');
  }

  get walletAddress() {
    this.ensureInitialized();
    return this.components.get('walletAddress');
  }

  get openseaApi() {
    this.ensureInitialized();
    return this.components.get('openseaApi');
  }

  get cacheService() {
    this.ensureInitialized();
    return this.components.get('cacheService');
  }

  // Component initialization methods
  async initializeChainConfig() {
    const startTime = Date.now();

    const chainConfig = await getEffectiveChain(this.options);

    if (!chainConfig) {
      throw new ValidationError('Chain configuration not found', {
        availableChains: SUPPORTED_CHAINS.map(c => c.name)
      });
    }

    this.components.set('chainConfig', chainConfig);
    this.recordPerformance('chain_config', Date.now() - startTime);
  }

  async initializeWallet() {
    const startTime = Date.now();

    const wallet = await getWallet(this.options);

    if (!wallet) {
      throw new ValidationError('Wallet initialization failed', {
        reason: 'Invalid private key or wallet configuration'
      });
    }

    this.components.set('wallet', wallet);
    this.recordPerformance('wallet', Date.now() - startTime);
  }

  async initializeAddress() {
    const startTime = Date.now();

    const wallet = this.wallet;
    const walletAddress = await wallet.getAddress();

    if (!walletAddress) {
      throw new ValidationError('Failed to get wallet address', {
        walletProvider: wallet.provider?.constructor?.name
      });
    }

    this.components.set('walletAddress', walletAddress.toLowerCase());
    this.recordPerformance('address', Date.now() - startTime);
  }

  async initializeApiClients() {
    const startTime = Date.now();
    const { chainConfig } = this;

    // Initialize OpenSea API
    if (!OPENSEA_API_KEY) {
      throw new ConfigurationError('OpenSea API key not configured', {
        envVar: 'OPENSEA_API_KEY',
        configLocation: '.env file'
      });
    }

    const openseaApi = new OpenSeaApi(
      OPENSEA_API_KEY,
      OPENSEA_API_BASE_URL,
      chainConfig
    );

    this.components.set('openseaApi', openseaApi);
    this.recordPerformance('opensea_api', Date.now() - startTime);
  }

  async initializeServices() {
    const startTime = Date.now();

    // Initialize Cache Service
    const cacheService = new CacheService();
    this.components.set('cacheService', cacheService);

    // Initialize logger if debug mode
    if (this.options.debug) {
      logger.setLevel(LogLevel.DEBUG);
    }

    this.recordPerformance('services', Date.now() - startTime);
  }

  async validateContext() {
    const requiredComponents = ['chainConfig', 'wallet', 'walletAddress'];
    const missingComponents = requiredComponents.filter(
      component => !this.components.has(component)
    );

    if (missingComponents.length > 0) {
      throw new ContextValidationError('Missing required context components', {
        missing: missingComponents,
        available: Array.from(this.components.keys())
      });
    }

    // Validate component consistency
    await this.validateChainConsistency();
    await this.validateWalletConsistency();
    await this.validateApiConnectivity();
  }

  ensureInitialized() {
    if (!this.isInitialized) {
      throw new ContextError('ExecutionContext not initialized. Call init() first.');
    }
  }

  recordPerformance(operation, duration) {
    this.performanceMetrics.set(operation, {
      duration,
      timestamp: Date.now()
    });
  }

  getPerformanceReport() {
    const report = {};
    for (const [operation, metrics] of this.performanceMetrics) {
      report[operation] = `${metrics.duration}ms`;
    }
    return report;
  }
}
```

### Context Builder Pattern Implementation
[Source: Builder pattern for flexible configuration]

**Fluent Builder Architecture:**
```javascript
export class ExecutionContextBuilder {
  constructor() {
    this.options = {};
    this.presets = new Set();
    this.customizers = [];
  }

  static forCommand(commandName, commandOptions = {}) {
    return new ExecutionContextBuilder()
      .withCommand(commandName, commandOptions);
  }

  withCommand(commandName, options = {}) {
    this.options.command = commandName;
    this.options = { ...this.options, ...options };
    return this;
  }

  withChain(chainName) {
    this.options.chain = chainName;
    return this;
  }

  withPrivateKey(privateKey) {
    this.options.privateKey = privateKey;
    return this;
  }

  withDebug(enabled = true) {
    this.options.debug = enabled;
    return this;
  }

  withCache(enabled = true) {
    this.options.enableCache = enabled;
    return this;
  }

  withPreset(preset) {
    this.presets.add(preset);
    return this;
  }

  customize(customizer) {
    this.customizers.push(customizer);
    return this;
  }

  async build() {
    // Apply presets
    for (const preset of this.presets) {
      this.applyPreset(preset);
    }

    // Apply customizers
    for (const customizer of this.customizers) {
      await customizer(this.options);
    }

    const context = new ExecutionContext(this.options);
    return await context.init();
  }

  applyPreset(preset) {
    switch (preset) {
      case 'monitoring':
        this.options.enableCache = true;
        this.options.enableMetrics = true;
        this.options.timeout = 30000;
        break;

      case 'trading':
        this.options.enableCache = true;
        this.options.enableValidation = true;
        this.options.confirmationRequired = true;
        break;

      case 'development':
        this.options.debug = true;
        this.options.enableCache = false;
        this.options.timeout = 60000;
        break;

      default:
        throw new Error(`Unknown preset: ${preset}`);
    }
  }
}

// Usage examples
const context1 = await ExecutionContextBuilder
  .forCommand('monitor', { collections: 'azuki' })
  .withPreset('monitoring')
  .withChain('ethereum')
  .build();

const context2 = await ExecutionContextBuilder
  .forCommand('offer', { address: '0x...', tokenId: '123' })
  .withPreset('trading')
  .withDebug(true)
  .build();
```

### Context Caching System
[Source: Caching patterns and performance optimization strategies]

**Context Cache Implementation:**
```javascript
export class ContextCache {
  constructor(options = {}) {
    this.cache = new Map();
    this.ttl = options.ttl || 300000; // 5 minutes default
    this.maxSize = options.maxSize || 100;
    this.cleanupInterval = options.cleanupInterval || 60000; // 1 minute
    this.startCleanupTimer();
  }

  static getInstance() {
    if (!ContextCache.instance) {
      ContextCache.instance = new ContextCache();
    }
    return ContextCache.instance;
  }

  generateCacheKey(options) {
    // Create a deterministic key from options
    const keyComponents = [
      options.chain || 'default',
      options.privateKey ? 'has_key' : 'no_key',
      options.debug ? 'debug' : 'nodebug',
      JSON.stringify(options.command || {})
    ];

    return Buffer.from(keyComponents.join('|')).toString('base64');
  }

  async get(options) {
    const key = this.generateCacheKey(options);
    const entry = this.cache.get(key);

    if (!entry) {
      return null;
    }

    // Check TTL
    if (Date.now() - entry.timestamp > this.ttl) {
      this.cache.delete(key);
      return null;
    }

    // Update access time
    entry.lastAccessed = Date.now();
    return entry.context;
  }

  async set(options, context) {
    const key = this.generateCacheKey(options);

    // Implement LRU eviction if cache is full
    if (this.cache.size >= this.maxSize) {
      this.evictLeastRecentlyUsed();
    }

    const entry = {
      context,
      timestamp: Date.now(),
      lastAccessed: Date.now()
    };

    this.cache.set(key, entry);
  }

  evictLeastRecentlyUsed() {
    let oldestKey = null;
    let oldestTime = Date.now();

    for (const [key, entry] of this.cache) {
      if (entry.lastAccessed < oldestTime) {
        oldestTime = entry.lastAccessed;
        oldestKey = key;
      }
    }

    if (oldestKey) {
      this.cache.delete(oldestKey);
    }
  }

  startCleanupTimer() {
    setInterval(() => {
      this.cleanup();
    }, this.cleanupInterval);
  }

  cleanup() {
    const now = Date.now();
    for (const [key, entry] of this.cache) {
      if (now - entry.timestamp > this.ttl) {
        this.cache.delete(key);
      }
    }
  }

  getStats() {
    return {
      size: this.cache.size,
      maxSize: this.maxSize,
      ttl: this.ttl,
      hitRate: this.hitRate
    };
  }
}
```

### Command Refactoring Pattern
[Source: Existing command patterns and refactoring strategies]

**Before Refactoring (Current Pattern):**
```javascript
// listCommand.js - Repetitive initialization block
listCommand.action(async (options) => {
  try {
    const chainConfig = await getEffectiveChain(options);
    const wallet = await getWallet(options);
    const walletAddress = await wallet.getAddress();

    if (options.debug) {
      logger.setLevel(LogLevel.DEBUG);
    }

    const openseaApi = new OpenSeaApi(OPENSEA_API_KEY, OPENSEA_API_BASE_URL, chainConfig);
    const cacheService = new CacheService();

    // Rest of command logic...
  } catch (error) {
    logger.error('Command failed:', error.message);
    process.exit(1);
  }
});
```

**After Refactoring (New Pattern):**
```javascript
// listCommand.js - Simplified with ExecutionContext
listCommand.action(async (options) => {
  try {
    const context = await ExecutionContextBuilder
      .forCommand('list', options)
      .withCache(true)
      .build();

    if (options.interactive) {
      const interactiveService = new InteractiveListingService(context);
      return await interactiveService.runInteractiveListing(options);
    } else {
      return await createDirectListing(context, options);
    }

  } catch (error) {
    logger.error('List command failed:', error.message);
    process.exit(1);
  }
});
```

### Error Handling Enhancements
[Source: Error handling patterns and user experience design]

**Context-Specific Error Types:**
```javascript
export class ContextError extends Error {
  constructor(message, code = 'CONTEXT_ERROR', context = {}) {
    super(message);
    this.name = 'ContextError';
    this.code = code;
    this.context = context;
    this.timestamp = new Date().toISOString();
  }
}

export class ContextInitializationError extends ContextError {
  constructor(message, originalError) {
    super(message, 'CONTEXT_INITIALIZATION_ERROR', {
      originalError: originalError?.message
    });
    this.originalError = originalError;
  }
}

export class ContextValidationError extends ContextError {
  constructor(message, validationDetails) {
    super(message, 'CONTEXT_VALIDATION_ERROR', validationDetails);
    this.validationDetails = validationDetails;
  }
}

export class ContextCacheError extends ContextError {
  constructor(message, cacheOperation) {
    super(message, 'CONTEXT_CACHE_ERROR', { cacheOperation });
    this.cacheOperation = cacheOperation;
  }
}
```

**Enhanced Error Messages:**
```javascript
// Helpful error messages for common issues
function createHelpfulErrorMessage(error, context) {
  const baseMessage = error.message;

  switch (error.code) {
    case 'CONTEXT_VALIDATION_ERROR':
      if (error.context.missing?.includes('chainConfig')) {
        return `${baseMessage}\n\nðŸ’¡ Tip: Use --chain flag to specify blockchain (ethereum, base, sepolia)`;
      }
      if (error.context.missing?.includes('wallet')) {
        return `${baseMessage}\n\nðŸ’¡ Tip: Use --private-key flag or set up encrypted wallet with "key add" command`;
      }
      break;

    case 'CONTEXT_INITIALIZATION_ERROR':
      return `${baseMessage}\n\nðŸ” Check your configuration:\n- OPENSEA_API_KEY environment variable\n- Network connectivity\n- Private key format`;
  }

  return baseMessage;
}
```

### Performance Monitoring Integration
[Source: Performance monitoring patterns and metrics collection]

**Performance Metrics Collection:**
```javascript
export class ContextPerformanceMonitor {
  constructor() {
    this.metrics = new Map();
    this.benchmarks = new Map();
  }

  startTimer(operation) {
    this.metrics.set(operation, {
      startTime: process.hrtime.bigint(),
      memoryStart: process.memoryUsage()
    });
  }

  endTimer(operation) {
    const metric = this.metrics.get(operation);
    if (!metric) return;

    const endTime = process.hrtime.bigint();
    const memoryEnd = process.memoryUsage();

    const duration = Number(endTime - metric.startTime) / 1000000; // Convert to milliseconds
    const memoryDelta = {
      rss: memoryEnd.rss - metric.memoryStart.rss,
      heapUsed: memoryEnd.heapUsed - metric.memoryStart.heapUsed,
      heapTotal: memoryEnd.heapTotal - metric.memoryStart.heapTotal
    };

    this.metrics.set(operation, {
      duration,
      memoryDelta,
      timestamp: Date.now()
    });
  }

  getReport() {
    const report = {};
    for (const [operation, metric] of this.metrics) {
      report[operation] = {
        duration: `${metric.duration.toFixed(2)}ms`,
        memoryDelta: `${(metric.memoryDelta.heapUsed / 1024 / 1024).toFixed(2)}MB`,
        timestamp: new Date(metric.timestamp).toISOString()
      };
    }
    return report;
  }

  recordBenchmark(operation, duration) {
    if (!this.benchmarks.has(operation)) {
      this.benchmarks.set(operation, []);
    }
    this.benchmarks.get(operation).push(duration);
  }

  getBenchmarkStats(operation) {
    const measurements = this.benchmarks.get(operation) || [];
    if (measurements.length === 0) return null;

    measurements.sort((a, b) => a - b);
    return {
      count: measurements.length,
      min: measurements[0],
      max: measurements[measurements.length - 1],
      median: measurements[Math.floor(measurements.length / 2)],
      p95: measurements[Math.floor(measurements.length * 0.95)],
      average: measurements.reduce((sum, val) => sum + val, 0) / measurements.length
    };
  }
}
```

### Testing Strategy
[Source: Testing best practices for context management and dependency injection]

**Unit Testing Categories:**
- ExecutionContext initialization and validation
- Builder pattern configuration and presets
- Context caching and TTL behavior
- Error handling and validation scenarios
- Performance monitoring and metrics collection

**Integration Testing Categories:**
- Command refactoring compatibility
- Context sharing between multiple operations
- Error propagation through context layers
- Performance regression detection

**Mock Strategy:**
```javascript
// Mock external dependencies for isolated testing
jest.mock('../utils/commandUtils.js', () => ({
  getEffectiveChain: jest.fn(),
  getWallet: jest.fn()
}));

jest.mock('../services/openseaApi.js', () => ({
  OpenSeaApi: jest.fn()
}));

jest.mock('../services/cacheService.js', () => ({
  CacheService: jest.fn()
}));
```

### File Locations and Structure
[Source: docs/architecture/source-tree.md]

**New Files to Create:**
- `src/utils/ExecutionContext.js` - Main context class
- `src/utils/ExecutionContextBuilder.js` - Builder pattern implementation
- `src/utils/ContextCache.js` - Context caching system
- `src/utils/ContextPerformanceMonitor.js` - Performance monitoring
- `src/utils/errors/ContextError.js` - Context-specific error types
- `src/__tests__/ExecutionContext.test.js` - Context class tests
- `src/__tests__/ExecutionContextBuilder.test.js` - Builder tests
- `src/__tests__/ContextCache.test.js` - Caching tests
- `src/__tests__/ContextPerformanceMonitor.test.js` - Performance tests

**Files to Modify:**
- `src/commands/offerCommand.js` - Use ExecutionContext
- `src/commands/listCommand.js` - Use ExecutionContext
- `src/commands/monitorCommand.js` - Use ExecutionContext
- `src/commands/buyCommand.js` - Use ExecutionContext
- `src/commands/autoOfferCommand.js` - Use ExecutionContext
- `src/commands/balanceCommand.js` - Use ExecutionContext
- `src/commands/cacheCommand.js` - Use ExecutionContext
- `src/commands/checkOffersCommand.js` - Use ExecutionContext
- `src/commands/keyCommand.js` - Use ExecutionContext
- `src/commands/sendCommand.js` - Use ExecutionContext
- `src/commands/swapCommand.js` - Use ExecutionContext

### Migration Strategy
[Source: Incremental refactoring patterns and compatibility preservation]

**Phase 1: Core Infrastructure**
1. Create ExecutionContext and related utilities
2. Add comprehensive tests
3. Verify functionality in isolation

**Phase 2: Gradual Command Migration**
1. Start with simpler commands (balance, swap, send)
2. Progress to medium complexity commands (offer, buy)
3. Complete with complex commands (list, monitor, autoOffer)

**Phase 3: Validation and Optimization**
1. Comprehensive integration testing
2. Performance benchmarking and optimization
3. Documentation updates and migration guides

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-01-21 | 1.0 | Initial story creation | Winston (Architect Agent) |

## Dev Agent Record

### Agent Model Used
Claude Sonnet 4.5 (claude-sonnet-4-5-20250929)

### Debug Log References
- Code Duplication Analysis (2025-01-21): Found repetitive initialization patterns in 9+ command files
- Performance Analysis (2025-01-21): Identified optimization opportunities through context caching
- Architecture Planning (2025-01-21): Designed comprehensive context management system

### Completion Notes List
- ExecutionContext class designed to eliminate code duplication
- Builder pattern implementation for flexible configuration
- Context caching system for performance optimization
- Comprehensive error handling and validation
- Performance monitoring and metrics collection
- Migration strategy ensuring zero breaking changes
- Testing strategy covering all aspects of context management

### File List
**New Files to Create:**
- `src/utils/ExecutionContext.js` - Main context management class
- `src/utils/ExecutionContextBuilder.js` - Builder pattern implementation
- `src/utils/ContextCache.js` - Context caching and TTL management
- `src/utils/ContextPerformanceMonitor.js` - Performance monitoring
- `src/utils/errors/ContextError.js` - Context-specific error types
- `src/__tests__/ExecutionContext.test.js` - Context class unit tests
- `src/__tests__/ExecutionContextBuilder.test.js` - Builder pattern tests
- `src/__tests__/ContextCache.test.js` - Caching system tests
- `src/__tests__/ContextPerformanceMonitor.test.js` - Performance tests

**Files to Modify:**
- All 11 command files in `src/commands/` directory to use ExecutionContext
- Related test files for compatibility with new context system

**Story File:**
- `docs/stories/7.4.execution-context-refactor.md` - This story file