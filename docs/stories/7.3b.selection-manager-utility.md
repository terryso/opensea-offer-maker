# Story 7.3b: SelectionManager Utility - NFT and Collection Selection Logic

## Status
Draft

## Story
**As a** developer,
**I want** a reusable SelectionManager utility class to handle NFT and collection selection workflows,
**so that** I can provide consistent search, filtering, pagination, and selection experiences across all interactive CLI commands

## Acceptance Criteria
1. Create `SelectionManager` utility class in `src/utils/SelectionManager.js` that handles item selection from large datasets
2. Implement search and filtering capabilities for NFT and collection selection workflows
3. Add pagination and navigation support for large collections with configurable page sizes
4. Include selection validation and user preference handling with proper error handling
5. Create comprehensive unit tests with >90% coverage for all selection scenarios and edge cases
6. Follow existing coding standards and integrate with project's logger and prompt patterns

## Tasks / Subtasks

- [ ] Task 1: Create SelectionManager class structure and core functionality (AC: 1)
  - [ ] Define selection manager with configurable options (page size, search enabled, filters)
  - [ ] Implement main `selectFromList()` method for item selection
  - [ ] Add helper methods for item formatting and display
  - [ ] Create basic validation for input parameters

- [ ] Task 2: Implement search and filtering capabilities (AC: 2)
  - [ ] Add `promptSearch()` method for user input queries
  - [ ] Implement `searchItems()` with case-insensitive text search
  - [ ] Create `applyFilters()` method for structured filtering
  - [ ] Add support for multiple filter criteria and custom filter functions

- [ ] Task 3: Add pagination and navigation support (AC: 3)
  - [ ] Implement `selectWithPagination()` for large dataset handling
  - [ ] Add navigation controls (Next Page, Previous Page, Back, Cancel)
  - [ ] Create page boundary handling and page count calculation
  - [ ] Support configurable page sizes with intelligent defaults

- [ ] Task 4: Implement selection validation and preferences (AC: 4)
  - [ ] Add selection result validation with type checking
  - [ ] Implement user preference handling (recent selections, favorites)
  - [ ] Create proper error handling for invalid inputs and edge cases
  - [ ] Add support for selection callbacks and custom validation

- [ ] Task 5: Create comprehensive unit test suite (AC: 5)
  - [ ] Test all selection methods with various dataset sizes
  - [ ] Test search functionality with different query patterns
  - [ ] Test pagination navigation and boundary conditions
  - [ ] Test filtering logic with multiple criteria
  - [ ] Test error conditions and edge cases
  - [ ] Verify >90% code coverage using Jest

- [ ] Task 6: Integration verification and documentation (AC: 6)
  - [ ] Verify code follows existing coding standards
  - [ ] Ensure proper logger integration for debugging
  - [ ] Add comprehensive JSDoc documentation
  - [ ] Validate prompt patterns match existing CLI interactions

## Dev Notes

### Previous Story Insights
[Source: Analysis of Story 7.1, 7.2, and 7.3a completion]

**Learning from KeyManager Security Refactor (Story 7.1):**
- Proper error handling with custom error types is essential
- Environment variable configuration patterns should be followed
- Class-based utilities work well with existing architecture

**Learning from Error Handling Refactor (Story 7.2):**
- Consistent error messages across the codebase improve debugging
- Logger should be used instead of console.log for all error reporting
- Input validation should be comprehensive and defensive

**Learning from FlowStateManager (Story 7.3a):**
- Utility classes should be self-contained and reusable
- State management patterns work well for CLI interactions
- Proper testing coverage is critical for utility classes

### Technical Architecture Context

**SelectionManager Design Pattern:**
[Source: docs/prd/epic-7-system-refactoring.md#story-73-交互式挂单服务重构]

Based on the epic requirements and original listCommand.js analysis, the SelectionManager needs to handle:

- **NFT and collection selection logic** extracted from lines 400-650 of listCommand.js
- **Search and filtering capabilities** for large datasets
- **Pagination and navigation** for collections with many items
- **Selection validation** and user preference handling

**Key Functionality Extracted from listCommand.js:**
- `selectCollection()` (~150 lines) - Collection selection logic
- `selectNFT()` (~120 lines) - NFT selection logic
- Search and filter logic for NFT metadata
- Pagination handling for large collections

### File Location and Structure
[Source: docs/architecture/source-tree.md]

**Target Location:** `src/utils/SelectionManager.js`

The utils directory contains utility classes:
- `keyManager.js` - Security and encryption
- `commandUtils.js` - Chain and wallet management
- `configManager.js` - Configuration persistence
- `logger.js` - Logging system
- `proxySetup.js` - Network proxy configuration
- `FlowStateManager.js` - State management (new from 7.3a)

SelectionManager should follow the same patterns:
- ES Module exports (export class, export default)
- Proper error handling with logger
- Constructor-based dependency injection
- Comprehensive JSDoc documentation

**Integration with Existing CLI Patterns:**
[Source: docs/architecture/tech-stack.md]

The project uses:
- **enquirer** ^2.4.1 for interactive prompts
- **commander.js** ^12.1.0 for CLI framework

SelectionManager should integrate with these patterns:
```javascript
// Example prompt pattern from existing codebase
const choice = await prompt({
  type: 'select',
  name: 'selection',
  message: 'Select an item:',
  choices: formattedChoices
});
```

### Coding Standards
[Source: docs/architecture/coding-standards.md]

**Requirements:**
- Use ES2022 with ES Modules (package.json has `"type": "module"`)
- Follow camelCase file naming (`SelectionManager.js`)
- Use PascalCase for class names (`class SelectionManager`)
- Use logger from `src/utils/logger.js` - never console.log
- Proper error handling with try/catch blocks
- Add comprehensive JSDoc comments for public methods

**File Structure Pattern:**
```javascript
// src/utils/SelectionManager.js
import logger from './logger.js';

export class SelectionManager {
  constructor(options = {}) {
    this.pageSize = options.pageSize || 10;
    this.searchEnabled = options.searchEnabled !== false;
    this.filters = options.filters || {};
  }

  // public methods
}

export default SelectionManager;
```

### Testing Requirements
[Source: docs/architecture/testing.md]

**Test File Location:** `src/__tests__/SelectionManager.test.js`

**Testing Standards:**
- Use Jest framework with experimental VM modules
- Achieve >90% code coverage
- Mock enquirer prompts for testing
- Follow AAA pattern (Arrange, Act, Assert)
- Test all public methods and edge cases
- Test error conditions and validation

**Mock Strategy for Testing:**
```javascript
// Mock enquirer prompts
jest.mock('enquirer', () => ({
  prompt: jest.fn()
}));

import { prompt } from 'enquirer';
```

**Test Structure Example:**
```javascript
describe('SelectionManager', () => {
  let selectionManager;
  let mockPrompt;

  beforeEach(() => {
    mockPrompt = jest.fn();
    jest.mock('enquirer').prompt = mockPrompt;
    selectionManager = new SelectionManager();
  });

  describe('selectFromList', () => {
    it('should handle small datasets without pagination', async () => {
      // test implementation
    });

    it('should paginate large datasets', async () => {
      // test implementation
    });
  });
});
```

### Project Structure Alignment
[Source: docs/architecture/source-tree.md]

**Dependencies and Imports:**
- Should import logger from `./logger.js` (sibling utility)
- Can import FlowStateManager from `./FlowStateManager.js` for state coordination
- Should not import from services layer (maintain dependency direction)
- Can import constants from `../constants/` if needed
- Should be importable by commands and services

**Integration Points:**
- Will be used by future InteractiveListingService (Story 7.3d)
- May be used by other commands requiring item selection
- Should be designed as a reusable utility across the application
- Should integrate with existing enquirer prompt patterns

### Data Models and Structures
[Source: docs/architecture/data-models.md and listCommand.js analysis]

**NFT Data Structure:**
```javascript
{
  tokenId: string,
  name: string,
  collection: {
    slug: string,
    name: string,
    imageUrl: string
  },
  imageUrl: string,
  traits: Array,
  // ... other NFT metadata
}
```

**Collection Data Structure:**
```javascript
{
  slug: string,
  name: string,
  imageUrl: string,
  description: string,
  nftCount: number,
  // ... other collection metadata
}
```

SelectionManager should handle these data structures and provide flexible formatting for display.

### Performance Considerations
[Source: docs/architecture/tech-stack.md]

**Requirements:**
- Handle large datasets efficiently (1000+ items)
- Implement lazy loading for pagination
- Memory-efficient search and filtering
- Responsive UI during selection operations

**Optimization Strategies:**
- Search should be case-insensitive but performant
- Pagination should only load current page data
- Filtering should use efficient algorithms
- Cache search results when appropriate

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-01-21 | 1.0 | Initial story creation for SelectionManager utility | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
[To be populated by development agent]

### Debug Log References
[To be populated by development agent]

### Completion Notes List
[To be populated by development agent]

### File List
**Files to Create:**
- `src/utils/SelectionManager.js` - Main SelectionManager utility class
- `src/__tests__/SelectionManager.test.js` - Comprehensive unit test suite

**Files to Reference:**
- `src/utils/logger.js` - For logging functionality
- `src/utils/FlowStateManager.js` - For state coordination patterns
- `src/commands/listCommand.js` - For existing selection patterns to extract
- `docs/architecture/` for design patterns and standards

## QA Results
[To be populated by QA agent after implementation]