# Story 7.5: Logging System Standardization - Replace console.log with Structured Logging

## Status
Draft

## Story
**As a** developer,
**I want** consistent, structured logging throughout the application instead of console.log,
**so that** logs are standardized, controllable, and provide better debugging and monitoring capabilities

## Acceptance Criteria
1. All 42 instances of `console.log` across 9 files replaced with proper logger usage
2. Structured logging system implemented with configurable log levels (DEBUG, INFO, WARN, ERROR)
3. Log formatting standardized with timestamps, log levels, and consistent message structure
4. Context-aware logging implemented with request/user context preservation
5. Log rotation and retention policies implemented for production environments
6. Comprehensive unit tests created for logging system with >95% coverage
7. All existing functionality preserved with no breaking changes to user experience

## Tasks / Subtasks

### Task 1: Enhanced Logger Implementation (AC: 2, 3)
- [ ] Extend existing logger.js with structured logging capabilities
- [ ] Implement configurable log levels with runtime level changes
- [ ] Add structured log formatting with JSON and human-readable formats
- [ ] Create log output destinations (console, file, external services)
- [ ] Add unit tests for all logger functionality and edge cases

### Task 2: Context-Aware Logging System (AC: 4)
- [ ] Implement context propagation through the application
- [ ] Add request/user context to all log entries
- [ ] Create context middleware for automatic context injection
- [ ] Add correlation IDs for request tracking across services
- [ ] Create tests for context propagation and correlation

### Task 3: Log Rotation and Retention (AC: 5)
- [ ] Implement log rotation based on file size and time
- [ ] Add configurable retention policies for different log levels
- [ ] Create log compression for archived logs
- [ ] Add log cleanup and maintenance automation
- [ ] Create tests for rotation and retention functionality

### Task 4: Systematic console.log Replacement (AC: 1, 7)
- [ ] Replace console.log in buyService.js (14 occurrences)
- [ ] Replace console.log in pollingMonitorService.js
- [ ] Replace console.log in streamService.js
- [ ] Replace console.log in offerService.js (8 occurrences)
- [ ] Replace console.log in remaining services and utils
- [ ] Add regression tests to ensure no behavior changes

### Task 5: Logging Configuration Management (AC: 2)
- [ ] Create comprehensive logging configuration system
- [ ] Add environment-based configuration overrides
- [ ] Implement runtime log level adjustment
- [ ] Create logging presets for different environments (dev, test, prod)
- [ ] Add configuration validation and error handling

### Task 6: Performance Optimization (AC: 7)
- [ ] Implement async logging to prevent blocking operations
- [ ] Add log buffering and batch processing
- [ ] Optimize memory usage for high-volume logging
- [ ] Add performance monitoring for logging operations
- [ ] Create performance tests and benchmarks

### Task 7: Comprehensive Testing Suite (AC: 6)
- [ ] Create unit tests for enhanced logger functionality
- [ ] Create integration tests for context propagation
- [ ] Add performance tests for high-volume logging scenarios
- [ ] Create end-to-end tests for complete logging workflows
- [ ] Verify test coverage exceeds 95% for logging system

## Dev Notes

### Previous Story Insights
[Source: Analysis of console.log usage across the codebase and logging best practices]

**Current Logging Issues Identified:**
- 42 instances of `console.log` found across 9 files violating coding standards
- Inconsistent log levels and message formats across services
- No structured logging or context preservation
- Performance impact from synchronous logging operations
- No log rotation or retention management
- Debug information potentially leaking to production logs

**Learning from Security Analysis:**
- Structured logging essential for security monitoring and incident response
- Context preservation required for debugging complex workflows
- Log levels must be configurable to prevent information leakage
- Performance optimization critical for high-frequency operations

### Current console.log Usage Analysis
[Source: Grep analysis of codebase showing console.log patterns]

**Files with console.log Usage:**
1. `src/services/buyService.js` - 14 occurrences (debug and user feedback)
2. `src/services/pollingMonitorService.js` - 1 occurrence (status output)
3. `src/services/streamService.js` - 1 occurrence (connection status)
4. `src/services/offerService.js` - 8 occurrences (operation feedback)
5. `src/cli.js` - 2 occurrences (startup messages)
6. `src/__tests__/` directory - Multiple occurrences in test files
7. Other utility and service files

**Common Patterns Found:**
```javascript
// Debug information
console.log('Processing offer for collection:', collectionSlug);
console.log('Offer parameters:', params);

// User feedback
console.log('✅ Purchase completed successfully!');
console.log('❌ Insufficient balance');

// Status updates
console.log('Connected to OpenSea Stream API');
console.log('Monitoring started for wallet:', walletAddress);
```

### Enhanced Logger Architecture
[Source: Existing logger.js analysis and structured logging best practices]

**Current Logger Enhancement Plan:**
```javascript
// src/utils/logger.js - Enhanced version
import { createWriteStream, WriteStream } from 'fs';
import { join } from 'path';

export class Logger {
  constructor(options = {}) {
    this.level = options.level || LogLevel.INFO;
    this.format = options.format || 'human'; // 'human' | 'json'
    this.destinations = options.destinations || ['console'];
    this.context = options.context || {};
    this.enableFileLogging = options.enableFileLogging || false;
    this.logFile = options.logFile || 'app.log';
    this.maxFileSize = options.maxFileSize || 10 * 1024 * 1024; // 10MB
    this.maxFiles = options.maxFiles || 5;
    this.fileStream = null;

    this.initializeFileLogging();
  }

  initializeFileLogging() {
    if (this.enableFileLogging && this.destinations.includes('file')) {
      this.setupFileRotation();
    }
  }

  setupFileRotation() {
    this.fileStream = createWriteStream(this.logFile, { flags: 'a' });

    // Monitor file size for rotation
    this.fileStream.on('error', (error) => {
      console.error('Logger file stream error:', error);
    });
  }

  rotateLogFile() {
    if (this.fileStream) {
      this.fileStream.end();

      // Implement log rotation logic
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
      const archiveName = `${this.logFile}.${timestamp}`;

      // Rename current log file
      fs.renameSync(this.logFile, archiveName);

      // Create new log file
      this.fileStream = createWriteStream(this.logFile, { flags: 'a' });

      // Clean up old log files
      this.cleanupOldLogs();
    }
  }

  cleanupOldLogs() {
    // Implement cleanup logic based on maxFiles
    // This would scan for archived log files and remove oldest ones
  }

  log(level, message, meta = {}) {
    if (!this.shouldLog(level)) {
      return;
    }

    const logEntry = this.createLogEntry(level, message, meta);

    if (this.destinations.includes('console')) {
      this.logToConsole(logEntry);
    }

    if (this.destinations.includes('file') && this.fileStream) {
      this.logToFile(logEntry);
    }

    // Check file size for rotation
    this.checkFileSize();
  }

  createLogEntry(level, message, meta) {
    const timestamp = new Date().toISOString();
    const context = { ...this.context, ...meta };

    const logEntry = {
      timestamp,
      level: LogLevel[level],
      message,
      context,
      pid: process.pid,
      hostname: require('os').hostname()
    };

    // Add correlation ID if available
    if (context.correlationId) {
      logEntry.correlationId = context.correlationId;
    }

    return logEntry;
  }

  logToConsole(logEntry) {
    if (this.format === 'json') {
      console.log(JSON.stringify(logEntry));
    } else {
      const coloredLevel = this.colorizeLevel(logEntry.level);
      const contextStr = Object.keys(logEntry.context).length > 0
        ? ` ${JSON.stringify(logEntry.context)}`
        : '';

      console.log(`${logEntry.timestamp} ${coloredLevel} ${logEntry.message}${contextStr}`);
    }
  }

  logToFile(logEntry) {
    if (this.format === 'json') {
      this.fileStream.write(JSON.stringify(logEntry) + '\n');
    } else {
      const contextStr = Object.keys(logEntry.context).length > 0
        ? ` ${JSON.stringify(logEntry.context)}`
        : '';

      this.fileStream.write(`${logEntry.timestamp} ${logEntry.level} ${logEntry.message}${contextStr}\n`);
    }
  }

  colorizeLevel(level) {
    const colors = {
      DEBUG: '\x1b[36m', // Cyan
      INFO: '\x1b[32m',  // Green
      WARN: '\x1b[33m',  // Yellow
      ERROR: '\x1b[31m'  // Red
    };

    const reset = '\x1b[0m';
    return `${colors[level]}${level}${reset}`;
  }

  shouldLog(level) {
    return LogLevel[level] <= LogLevel[this.level];
  }

  checkFileSize() {
    if (this.fileStream && this.enableFileLogging) {
      try {
        const stats = fs.statSync(this.logFile);
        if (stats.size > this.maxFileSize) {
          this.rotateLogFile();
        }
      } catch (error) {
        // File might not exist yet
      }
    }
  }

  // Convenience methods
  debug(message, meta) {
    this.log('DEBUG', message, meta);
  }

  info(message, meta) {
    this.log('INFO', message, meta);
  }

  warn(message, meta) {
    this.log('WARN', message, meta);
  }

  error(message, meta) {
    this.log('ERROR', message, meta);
  }

  // Context management
  withContext(context) {
    return new Logger({
      ...this.getOptions(),
      context: { ...this.context, ...context }
    });
  }

  setLevel(level) {
    this.level = level;
  }

  getOptions() {
    return {
      level: this.level,
      format: this.format,
      destinations: this.destinations,
      context: this.context,
      enableFileLogging: this.enableFileLogging,
      logFile: this.logFile,
      maxFileSize: this.maxFileSize,
      maxFiles: this.maxFiles
    };
  }
}

// Singleton instance with default configuration
export const logger = new Logger({
  level: process.env.LOG_LEVEL || 'INFO',
  format: process.env.NODE_ENV === 'production' ? 'json' : 'human',
  destinations: process.env.NODE_ENV === 'production' ? ['file'] : ['console'],
  enableFileLogging: process.env.ENABLE_FILE_LOGGING === 'true',
  logFile: process.env.LOG_FILE || 'logs/app.log'
});

// Log level constants
export const LogLevel = {
  DEBUG: 0,
  INFO: 1,
  WARN: 2,
  ERROR: 3
};
```

### Context-Aware Logging Implementation
[Source: Context propagation patterns and correlation tracking]

**Context Management System:**
```javascript
// src/utils/LoggerContext.js
import { v4 as uuidv4 } from 'uuid';

export class LoggerContext {
  constructor() {
    this.context = new Map();
    this.correlationId = null;
  }

  static getCurrent() {
    if (!LoggerContext.current) {
      LoggerContext.current = new LoggerContext();
    }
    return LoggerContext.current;
  }

  static run(context, callback) {
    const previous = LoggerContext.current;
    LoggerContext.current = new LoggerContext().merge(context);

    try {
      return callback();
    } finally {
      LoggerContext.current = previous;
    }
  }

  static async runAsync(context, callback) {
    const previous = LoggerContext.current;
    LoggerContext.current = new LoggerContext().merge(context);

    try {
      return await callback();
    } finally {
      LoggerContext.current = previous;
    }
  }

  merge(context) {
    const newContext = new LoggerContext();
    newContext.context = new Map(this.context);

    for (const [key, value] of Object.entries(context)) {
      newContext.context.set(key, value);
    }

    newContext.correlationId = context.correlationId || this.correlationId || uuidv4();
    return newContext;
  }

  get(key) {
    return this.context.get(key);
  }

  set(key, value) {
    this.context.set(key, value);
  }

  getAll() {
    const result = {};
    for (const [key, value] of this.context) {
      result[key] = value;
    }

    if (this.correlationId) {
      result.correlationId = this.correlationId;
    }

    return result;
  }

  withCorrelationId(correlationId) {
    const newContext = new LoggerContext();
    newContext.context = new Map(this.context);
    newContext.correlationId = correlationId;
    return newContext;
  }
}

// Enhanced logger with context awareness
export class ContextAwareLogger {
  constructor(baseLogger) {
    this.baseLogger = baseLogger;
  }

  log(level, message, meta = {}) {
    const context = LoggerContext.getCurrent().getAll();
    const enhancedMeta = { ...context, ...meta };

    this.baseLogger.log(level, message, enhancedMeta);
  }

  debug(message, meta) {
    this.log('DEBUG', message, meta);
  }

  info(message, meta) {
    this.log('INFO', message, meta);
  }

  warn(message, meta) {
    this.log('WARN', message, meta);
  }

  error(message, meta) {
    this.log('ERROR', message, meta);
  }

  withContext(context) {
    return new ContextAwareLogger(
      this.baseLogger.withContext(context)
    );
  }
}

// Usage in services
export const contextLogger = new ContextAwareLogger(logger);
```

### Service Integration Patterns
[Source: Service layer integration patterns and dependency injection]

**Service Logger Integration:**
```javascript
// Base service class with logging
export class BaseService {
  constructor(options = {}) {
    this.logger = options.logger || contextLogger;
    this.serviceName = this.constructor.name;
  }

  logWithContext(level, message, meta = {}) {
    this.logger.log(level, message, {
      service: this.serviceName,
      ...meta
    });
  }

  debug(message, meta) {
    this.logWithContext('DEBUG', message, meta);
  }

  info(message, meta) {
    this.logWithContext('INFO', message, meta);
  }

  warn(message, meta) {
    this.logWithContext('WARN', message, meta);
  }

  error(message, meta) {
    this.logWithContext('ERROR', message, meta);
  }

  async withOperationLogging(operationName, operationCallback) {
    const startTime = Date.now();

    this.info(`Starting operation: ${operationName}`);

    try {
      const result = await operationCallback();
      const duration = Date.now() - startTime;

      this.info(`Operation completed: ${operationName}`, {
        duration,
        success: true
      });

      return result;
    } catch (error) {
      const duration = Date.now() - startTime;

      this.error(`Operation failed: ${operationName}`, {
        duration,
        success: false,
        error: error.message
      });

      throw error;
    }
  }
}

// Usage in existing services
export class OfferService extends BaseService {
  constructor(options = {}) {
    super(options);
    // ... other initialization
  }

  async createOffer(params) {
    return this.withOperationLogging('createOffer', async () => {
      this.debug('Creating offer with parameters', {
        collection: params.collectionSlug,
        amount: params.amount
      });

      // Existing offer creation logic
      const result = await this.actualCreateOffer(params);

      this.info('Offer created successfully', {
        orderId: result.orderHash,
        collection: params.collectionSlug
      });

      return result;
    });
  }
}
```

### console.log Replacement Strategy
[Source: Systematic refactoring patterns and behavior preservation]

**Replacement Patterns by Use Case:**

**1. Debug Information:**
```javascript
// Before
console.log('Processing offer for collection:', collectionSlug);
console.log('Offer parameters:', params);

// After
logger.debug('Processing offer for collection', {
  collectionSlug,
  params: this.sanitizeParams(params)
});
```

**2. User Feedback:**
```javascript
// Before
console.log('✅ Purchase completed successfully!');
console.log('❌ Insufficient balance');

// After
logger.info('Purchase completed successfully', {
  success: true,
  userMessage: true
});

logger.warn('Insufficient balance', {
  userMessage: true,
  balance: currentBalance,
  required: requiredBalance
});
```

**3. Status Updates:**
```javascript
// Before
console.log('Connected to OpenSea Stream API');
console.log('Monitoring started for wallet:', walletAddress);

// After
logger.info('Connected to OpenSea Stream API', {
  service: 'StreamService',
  connection: true
});

logger.info('Monitoring started', {
  service: 'StreamService',
  walletAddress: this.sanitizeAddress(walletAddress),
  collections: collections.length
});
```

**4. Error Logging:**
```javascript
// Before
console.log('Failed to create offer:', error.message);

// After
logger.error('Failed to create offer', {
  error: error.message,
  stack: error.stack,
  operation: 'createOffer'
});
```

### Configuration Management
[Source: Configuration patterns and environment-based setup]

**Logging Configuration System:**
```javascript
// src/config/logging.js
export const loggingConfig = {
  development: {
    level: 'DEBUG',
    format: 'human',
    destinations: ['console'],
    enableFileLogging: false,
    colors: true
  },

  test: {
    level: 'ERROR',
    format: 'json',
    destinations: ['file'],
    enableFileLogging: true,
    logFile: 'test.log',
    colors: false
  },

  production: {
    level: 'INFO',
    format: 'json',
    destinations: ['file'],
    enableFileLogging: true,
    logFile: 'logs/app.log',
    maxFileSize: 50 * 1024 * 1024, // 50MB
    maxFiles: 10,
    colors: false
  }
};

export function getLoggingConfig() {
  const env = process.env.NODE_ENV || 'development';
  const config = loggingConfig[env] || loggingConfig.development;

  // Override with environment variables
  return {
    ...config,
    level: process.env.LOG_LEVEL || config.level,
    enableFileLogging: process.env.ENABLE_FILE_LOGGING === 'true' || config.enableFileLogging,
    logFile: process.env.LOG_FILE || config.logFile
  };
}
```

### Performance Optimization
[Source: Async logging patterns and performance monitoring]

**Async Logging Implementation:**
```javascript
// src/utils/AsyncLogger.js
export class AsyncLogger {
  constructor(options = {}) {
    this.queue = [];
    this.processing = false;
    this.batchSize = options.batchSize || 100;
    this.flushInterval = options.flushInterval || 1000; // 1 second
    this.maxQueueSize = options.maxQueueSize || 10000;

    this.startFlushTimer();
  }

  log(logEntry) {
    if (this.queue.length >= this.maxQueueSize) {
      // Drop oldest entries if queue is full
      this.queue.shift();
    }

    this.queue.push(logEntry);

    if (!this.processing && this.queue.length >= this.batchSize) {
      this.flush();
    }
  }

  async flush() {
    if (this.processing || this.queue.length === 0) {
      return;
    }

    this.processing = true;
    const batch = this.queue.splice(0, this.batchSize);

    try {
      await this.writeBatch(batch);
    } catch (error) {
      console.error('Failed to write log batch:', error);
      // Add entries back to queue for retry
      this.queue.unshift(...batch);
    } finally {
      this.processing = false;
    }
  }

  async writeBatch(batch) {
    // Implementation depends on destination
    // For file logging, batch writes for performance
    // For external services, send as single request
  }

  startFlushTimer() {
    setInterval(() => {
      if (this.queue.length > 0) {
        this.flush();
      }
    }, this.flushInterval);
  }

  async shutdown() {
    // Flush remaining entries before shutdown
    while (this.queue.length > 0) {
      await this.flush();
    }
  }
}
```

### Testing Strategy
[Source: Logging testing patterns and verification strategies]

**Test Categories:**
1. **Unit Tests**: Logger functionality, log levels, formatting
2. **Integration Tests**: Context propagation, service integration
3. **Performance Tests**: High-volume logging, async operations
4. **Regression Tests**: Behavior preservation after console.log replacement

**Mock Strategy:**
```javascript
// Test logger that captures log entries
export class TestLogger {
  constructor() {
    this.entries = [];
  }

  log(level, message, meta = {}) {
    this.entries.push({
      level,
      message,
      meta,
      timestamp: new Date()
    });
  }

  getEntries(level) {
    return this.entries.filter(entry => entry.level === level);
  }

  hasEntry(level, message) {
    return this.entries.some(entry =>
      entry.level === level && entry.message === message
    );
  }

  clear() {
    this.entries = [];
  }
}
```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-01-21 | 1.0 | Initial story creation | Winston (Architect Agent) |

## Dev Agent Record

### Agent Model Used
Claude Sonnet 4.5 (claude-sonnet-4-5-20250929)

### Debug Log References
- console.log Analysis (2025-01-21): Found 42 instances across 9 files requiring replacement
- Logging Standards Review (2025-01-21): Identified need for structured logging and context propagation
- Performance Analysis (2025-01-21): Planned async logging for performance optimization

### Completion Notes List
- Comprehensive logging system enhancement with structured logging
- Context-aware logging with correlation IDs for request tracking
- Systematic console.log replacement strategy preserving behavior
- Performance optimization with async logging and batching
- Log rotation and retention management for production
- Configuration management for different environments
- Testing strategy ensuring 95%+ coverage and behavior preservation

### File List
**New Files to Create:**
- `src/utils/LoggerContext.js` - Context management system
- `src/utils/AsyncLogger.js` - Async logging implementation
- `src/config/logging.js` - Logging configuration management
- `src/utils/BaseService.js` - Base service with logging
- `src/__tests__/LoggerContext.test.js` - Context tests
- `src/__tests__/AsyncLogger.test.js` - Async logger tests
- `src/__tests__/logging-integration.test.js` - Integration tests

**Files to Modify:**
- `src/utils/logger.js` - Enhanced with structured logging
- All services with console.log usage (buyService.js, offerService.js, etc.)
- `src/cli.js` - Replace console.log with proper logging
- Test files to work with enhanced logging system

**Story File:**
- `docs/stories/7.5.logging-system-standardization.md` - This story file